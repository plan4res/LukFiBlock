/*--------------------------------------------------------------------------*/
/*------------------------- File LukFiBlock.cpp ----------------------------*/
/*--------------------------------------------------------------------------*/
/** @file
 * Implementation of the LukFiBlock class.
 *
 * \author Antonio Frangioni \n
 *         Dipartimento di Informatica \n
 *         Universita' di Pisa \n
 *
 * \author Enrico Gorgone \n
 *         Dipartimento di Informatica \n
 *         Universita' di Pisa \n
 *
 * \copyright &copy; by Antonio Frangioni
 */
/*--------------------------------------------------------------------------*/
/*---------------------------- IMPLEMENTATION ------------------------------*/
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/*------------------------------ INCLUDES ----------------------------------*/
/*--------------------------------------------------------------------------*/

#include "LukFiBlock.h"
//#include "Observer.h"
//#include "SMSTypedefs.h"
#include <math.h>
#include <random>

#include <iostream>
#include <numeric>
#include <functional>   // std::plus
#include <algorithm>    // std::transform

/*--------------------------------------------------------------------------*/
/*------------------------- NAMESPACE AND USING ----------------------------*/
/*--------------------------------------------------------------------------*/

using namespace std;

using namespace SMSpp_di_unipi_it;

// vector dblVR2 of size [10,5]
LukFiBlock::LukFiFunction::dblVR2 A12 = {
                          { 0 , 0 , 0 , 0 , 0 } , { 2 , 1 , 1 , 1 , 3 } ,
                          { 1 , 2 , 1 , 1 , 2 } , { 1 , 4 , 1 , 2 , 2 } ,
			  { 3 , 2 , 1 , 0 , 1 } , { 0 , 2 , 1 , 0 , 1 } ,
			  { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 1 , 2 , 1 } ,
			  { 0 , 0 , 2 , 1 , 0 } , { 1 , 1 , 2 , 0 , 0 } };

// vector dblVR1 of size [10]
LukFiBlock::LukFiFunction::dblVR1 b12 =
                             { 1 , 5 , 10 , 2 , 4 , 3 , 1.7 , 2.5 , 6 , 3.5 };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// vector dblVR2 of size [10,5]
LukFiBlock::LukFiFunction::dblVR2 A13 = {
 {-16 , 2 , 0 , 1 , 0} , { 0 , -2 , 0 , 4 , 2} , {-3.5 , 0 , 2 , 0 , 0} ,
 {0 , -2 , 0 , -4 , -1} , {0 , -9 , -2 , 1 , -2.8} , {2 , 0 , -4 , 0 , 0} ,
 {-1 , -1 , -1 , -1 , -1} , {-1 , -2 , -3 , -2 , -1} , {1 , 2, 3 , 4 , 5} ,
 {1 , 1 , 1 , 1 , 1} };

// vector dblVR1 of size [10]
LukFiBlock::LukFiFunction::dblVR1 b13 =
                      { -40 , -2 , -0.25 , -4 , -4 , -1 , -40 , -60 , 5 , 1};

// vector dblVR2 of size [5,5]
LukFiBlock::LukFiFunction::dblVR2 C13 = {
                  {30 , -20 , -10 , 32 , -10} , {-20 , 39, -6 , -31 , 32 } ,
		  {-10 , -6 , 10 , -6 , -10} , {32 , -31 , -6 , 39 , -20} ,
                  {-10 , 32 , -10 , -20 , 30} };

// vector dblVR1 of size [5]
LukFiBlock::LukFiFunction::dblVR1 d13 = { 4 , 8 , 10 , 6 , 2 };

// vector dblVR1 of size [5]
LukFiBlock::LukFiFunction::dblVR1 e13 = { -15 , -27 , -36 , -18 , -12 };

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// vector dblVR2 of size [48,48]

LukFiBlock::LukFiFunction::dblVR2 A21 = {
 { 100000 , 273 , 1272 , 744 , 1138 , 1972 , 1580 , 1878 , 1539 , 1457 , 429 , 1129 , 1251 , 1421 , 588 , 334 , 837 , 1364 , 229 , 961 , 754 , 1169 , 1488 , 720 , 1280 , 816 , 664 , 1178 , 939 , 1698 , 983 , 1119 , 1029 , 1815 , 721 , 1753 , 330 , 1499 , 1107 , 1576 , 942 , 484 , 617 , 896 , 1184 , 1030 , 1718 , 604 } ,
 { 273 , 100000 , 999 , 809 , 866 , 1722 , 1338 , 1640 , 1266 , 1185 , 440 , 894 , 992 , 1173 , 334 , 358 , 626 , 1124 , 358 , 847 , 533 , 915 , 1219 , 481 , 1009 , 543 , 937 , 915 , 667 , 1441 , 812 , 848 , 776 , 1560 , 526 , 1494 , 598 , 1244 , 1304 , 1306 , 685 , 668 , 444 , 1157 , 1359 , 1176 , 1475 , 335 } ,
 { 1272 , 999 , 100000 , 1519 , 140 , 937 , 697 , 951 , 267 , 227 , 1229 , 587 , 369 , 554 , 721 , 1212 , 739 , 596 , 1291 , 1114 , 701 , 426 , 285 , 676 , 155 , 456 , 1936 , 319 , 337 , 604 , 907 , 214 , 424 , 748 , 817 , 666 , 1592 , 521 , 2172 , 356 , 467 , 1583 , 882 , 2139 , 2182 , 1961 , 781 , 678 } ,
 { 744 , 809 , 1519 , 100000 , 1425 , 1861 , 1473 , 1713 , 1761 , 1617 , 370 , 1073 , 1304 , 1369 , 1092 , 453 , 798 , 1283 , 973 , 565 , 1315 , 1204 , 1796 , 846 , 1447 , 1143 , 959 , 1275 , 1213 , 2085 , 742 , 1309 , 1479 , 1760 , 703 , 1727 , 872 , 1479 , 686 , 1698 , 1057 , 387 , 1252 , 904 , 668 , 443 , 1600 , 930 } ,
 { 1138 , 866 , 140 , 1425 , 100000 , 1052 , 776 , 1049 , 402 , 361 , 1119 , 578 , 406 , 618 , 581 , 1095 , 670 , 641 , 1152 , 1060 , 567 , 433 , 374 , 579 , 235 , 325 , 1802 , 331 , 217 , 665 , 862 , 182 , 312 , 864 , 732 , 783 , 1456 , 608 , 2066 , 491 , 400 , 1466 , 744 , 2013 , 2082 , 1865 , 875 , 552 } ,
 { 1972 , 1722 , 937 , 1861 , 1052 , 100000 , 400 , 182 , 820 , 721 , 1735 , 851 , 740 , 551 , 1551 , 1769 , 1159 , 613 , 2072 , 1300 , 1605 , 807 , 1017 , 1251 , 818 , 1259 , 2596 , 826 , 1137 , 1255 , 1123 , 943 , 1359 , 188 , 1282 , 271 , 2300 , 483 , 2540 , 609 , 1038 , 2099 , 1766 , 2699 , 2493 , 2266 , 264 , 1398 } ,
 { 1580 , 1338 , 697 , 1473 , 776 , 400 , 100000 , 304 , 699 , 538 , 1335 , 454 , 393 , 173 , 1198 , 1370 , 760 , 216 , 1692 , 919 , 1286 , 435 , 879 , 861 , 548 , 913 , 2198 , 483 , 803 , 1181 , 731 , 627 , 1086 , 292 , 883 , 279 , 1906 , 178 , 2156 , 490 , 662 , 1699 , 1430 , 2300 , 2117 , 1888 , 138 , 1023 } ,
 { 1878 , 1640 , 951 , 1713 , 1049 , 182 , 304 , 100000 , 884 , 755 , 1612 , 749 , 690 , 476 , 1501 , 1654 , 1049 , 516 , 1995 , 1149 , 1580 , 739 , 1079 , 1161 , 815 , 1214 , 2485 , 780 , 1100 , 1347 , 985 , 916 , 1361 , 260 , 1171 , 328 , 2202 , 445 , 2385 , 665 , 966 , 1969 , 1729 , 2568 , 2333 , 2108 , 177 , 1327 } ,
 { 1539 , 1266 , 267 , 1761 , 402 , 820 , 699 , 884 , 100000 , 177 , 1486 , 757 , 506 , 609 , 981 , 1474 , 967 , 681 , 1552 , 1317 , 936 , 594 , 197 , 928 , 316 , 723 , 2203 , 500 , 604 , 482 , 1104 , 455 , 630 , 641 , 1058 , 562 , 1857 , 528 , 2425 , 220 , 704 , 1845 , 1122 , 2405 , 2428 , 2204 , 738 , 945 } ,
 { 1457 , 1185 , 227 , 1617 , 361 , 721 , 538 , 755 , 177 , 100000 , 1362 , 587 , 335 , 435 , 930 , 1358 , 819 , 504 , 1496 , 1153 , 927 , 428 , 341 , 803 , 180 , 649 , 2119 , 343 , 521 , 652 , 939 , 340 , 649 , 533 , 918 , 451 , 1783 , 362 , 2290 , 130 , 568 , 1727 , 1105 , 2301 , 2285 , 2059 , 595 , 853 } ,
 { 429 , 440 , 1229 , 370 , 1119 , 1735 , 1335 , 1612 , 1486 , 1362 , 100000 , 891 , 1082 , 1199 , 726 , 96 , 583 , 1125 , 653 , 563 , 947 , 986 , 1493 , 560 , 1183 , 813 , 882 , 1033 , 902 , 1763 , 642 , 1032 , 1131 , 1604 , 463 , 1556 , 663 , 1298 , 947 , 1461 , 795 , 371 , 882 , 967 , 973 , 768 , 1472 , 588 } ,
 { 1129 , 894 , 587 , 1073 , 578 , 851 , 454 , 749 , 757 , 587 , 891 , 100000 , 252 , 308 , 803 , 920 , 309 , 238 , 1252 , 569 , 940 , 165 , 863 , 414 , 454 , 552 , 1745 , 269 , 482 , 1188 , 355 , 397 , 833 , 713 , 432 , 666 , 1453 , 410 , 1758 , 642 , 262 , 1260 , 1051 , 1858 , 1737 , 1508 , 592 , 598 } ,
 { 1251 , 992 , 369 , 1304 , 406 , 740 , 393 , 690 , 506 , 335 , 1082 , 252 , 100000 , 222 , 814 , 1094 , 510 , 235 , 1335 , 820 , 892 , 100 , 626 , 541 , 219 , 524 , 1897 , 90 , 410 , 952 , 605 , 238 , 706 , 570 , 622 , 503 , 1581 , 257 , 1985 , 396 , 309 , 1453 , 1039 , 2043 , 1972 , 1744 , 514 , 661 } ,
 { 1421 , 1173 , 554 , 1369 , 618 , 551 , 173 , 476 , 609 , 435 , 1199 , 308 , 222 , 100000 , 1025 , 1227 , 617 , 90 , 1525 , 835 , 1114 , 263 , 770 , 700 , 400 , 740 , 2049 , 311 , 630 , 1087 , 630 , 459 , 924 , 405 , 739 , 360 , 1749 , 115 , 2055 , 428 , 492 , 1568 , 1256 , 2166 , 2026 , 1796 , 303 , 853 } ,
 { 588 , 334 , 721 , 1092 , 581 , 1551 , 1198 , 1501 , 981 , 930 , 726 , 803 , 814 , 1025 , 100000 , 663 , 632 , 999 , 572 , 972 , 225 , 763 , 908 , 451 , 767 , 293 , 1240 , 726 , 420 , 1111 , 862 , 617 , 443 , 1374 , 586 , 1299 , 887 , 1070 , 1633 , 1057 , 547 , 999 , 252 , 1483 , 1681 , 1489 , 1326 , 236 } ,
 { 334 , 358 , 1212 , 453 , 1095 , 1769 , 1370 , 1654 , 1474 , 1358 , 96 , 920 , 1094 , 1227 , 663 , 100000 , 610 , 1156 , 557 , 642 , 879 , 1000 , 1467 , 558 , 1178 , 780 , 831 , 1038 , 879 , 1726 , 700 , 1023 , 1082 , 1631 , 488 , 1579 , 586 , 1320 , 982 , 1463 , 796 , 371 , 802 , 949 , 1021 , 826 , 1508 , 550 } ,
 { 837 , 626 , 739 , 798 , 670 , 1159 , 760 , 1049 , 967 , 819 , 583 , 309 , 510 , 617 , 632 , 610 , 100000 , 546 , 983 , 397 , 821 , 411 , 1023 , 180 , 651 , 478 , 1438 , 476 , 485 , 1333 , 235 , 525 , 827 , 1022 , 123 , 973 , 1155 , 715 , 1475 , 902 , 273 , 953 , 882 , 1550 , 1467 , 1240 , 898 , 396 } ,
 { 1364 , 1124 , 596 , 1283 , 641 , 613 , 216 , 516 , 681 , 504 , 1125 , 238 , 235 , 90 , 999 , 1156 , 546 , 100000 , 1479 , 745 , 1105 , 240 , 831 , 645 , 442 , 723 , 1983 , 316 , 623 , 1152 , 543 , 470 , 939 , 482 , 669 , 443 , 1690 , 205 , 1969 , 510 , 455 , 1492 , 1238 , 2091 , 1938 , 1709 , 354 , 813 } ,
 { 229 , 358 , 1291 , 973 , 1152 , 2072 , 1692 , 1995 , 1552 , 1496 , 653 , 1252 , 1335 , 1525 , 572 , 557 , 983 , 1479 , 100000 , 1163 , 676 , 1264 , 1473 , 839 , 1326 , 847 , 801 , 1254 , 976 , 1643 , 1157 , 1169 , 983 , 1905 , 878 , 1836 , 346 , 1590 , 1286 , 1621 , 1034 , 689 , 503 , 995 , 1376 , 1239 , 1828 , 674 } ,
 { 961 , 847 , 1114 , 565 , 1060 , 1300 , 919 , 1149 , 1317 , 1153 , 563 , 569 , 820 , 835 , 972 , 642 , 397 , 745 , 1163 , 100000 , 1183 , 725 , 1399 , 549 , 1004 , 869 , 1427 , 818 , 882 , 1716 , 214 , 902 , 1222 , 1210 , 390 , 1184 , 1225 , 949 , 1239 , 1210 , 660 , 863 , 1207 , 1446 , 1197 , 969 , 1042 , 741 } ,
 { 754 , 533 , 701 , 1315 , 567 , 1605 , 1286 , 1580 , 936 , 927 , 947 , 940 , 892 , 1114 , 225 , 879 , 821 , 1105 , 676 , 1183 , 100000 , 865 , 821 , 644 , 790 , 388 , 1374 , 803 , 484 , 968 , 1056 , 665 , 318 , 1420 , 794 , 1341 , 1017 , 1137 , 1836 , 1056 , 679 , 1200 , 189 , 1645 , 1891 , 1704 , 1403 , 442 } ,
 { 1169 , 915 , 426 , 1204 , 433 , 807 , 435 , 739 , 594 , 428 , 986 , 165 , 100 , 263 , 763 , 1000 , 411 , 240 , 1264 , 725 , 865 , 100000 , 699 , 453 , 290 , 483 , 1809 , 107 , 384 , 1024 , 511 , 251 , 712 , 646 , 525 , 585 , 1499 , 330 , 1885 , 495 , 231 , 1356 , 999 , 1949 , 1872 , 1644 , 567 , 591 } ,
 { 1488 , 1219 , 285 , 1796 , 374 , 1017 , 879 , 1079 , 197 , 341 , 1493 , 863 , 626 , 770 , 908 , 1467 , 1023 , 831 , 1473 , 1399 , 821 , 699 , 100000 , 950 , 410 , 690 , 2147 , 594 , 590 , 326 , 1191 , 499 , 504 , 838 , 1098 , 758 , 1794 , 703 , 2439 , 414 , 751 , 1837 , 1011 , 2374 , 2455 , 2237 , 928 , 921 } ,
 { 720 , 481 , 676 , 846 , 579 , 1251 , 861 , 1161 , 928 , 803 , 560 , 414 , 541 , 700 , 451 , 558 , 180 , 645 , 839 , 549 , 644 , 453 , 950 , 100000 , 624 , 325 , 1356 , 480 , 369 , 1241 , 413 , 473 , 680 , 1097 , 166 , 1038 , 1049 , 781 , 1497 , 905 , 238 , 925 , 702 , 1506 , 1506 , 1287 , 998 , 216 } ,
 { 1280 , 1009 , 155 , 1447 , 235 , 818 , 548 , 815 , 316 , 180 , 1183 , 454 , 219 , 400 , 767 , 1178 , 651 , 442 , 1326 , 1004 , 790 , 290 , 410 , 624 , 100000 , 479 , 1941 , 188 , 350 , 736 , 792 , 161 , 547 , 632 , 745 , 552 , 1607 , 375 , 2115 , 296 , 392 , 1547 , 959 , 2121 , 2114 , 1890 , 641 , 676 } ,
 { 816 , 543 , 456 , 1143 , 325 , 1259 , 913 , 1214 , 723 , 649 , 813 , 552 , 524 , 740 , 293 , 780 , 478 , 723 , 847 , 869 , 388 , 483 , 690 , 325 , 479 , 100000 , 1480 , 435 , 129 , 949 , 708 , 325 , 355 , 1081 , 492 , 1007 , 1137 , 779 , 1759 , 774 , 291 , 1148 , 516 , 1688 , 1785 , 1573 , 1038 , 231 } ,
 { 664 , 937 , 1936 , 959 , 1802 , 2596 , 2198 , 2485 , 2203 , 2119 , 882 , 1745 , 1897 , 2049 , 1240 , 831 , 1438 , 1983 , 801 , 1427 , 1374 , 1809 , 2147 , 1356 , 1941 , 1480 , 100000 , 1829 , 1603 , 2339 , 1524 , 1780 , 1673 , 2421 , 1315 , 2394 , 357 , 2136 , 825 , 2237 , 1589 , 579 , 1204 , 347 , 959 , 940 , 2336 , 1266 } ,
 { 1178 , 915 , 319 , 1275 , 331 , 826 , 483 , 780 , 500 , 343 , 1033 , 269 , 90 , 311 , 726 , 1038 , 476 , 316 , 1254 , 818 , 803 , 107 , 594 , 480 , 188 , 435 , 1829 , 100000 , 320 , 919 , 605 , 154 , 623 , 652 , 580 , 582 , 1508 , 344 , 1950 , 429 , 242 , 1402 , 949 , 1986 , 1943 , 1717 , 603 , 582 } ,
 { 939 , 667 , 337 , 1213 , 217 , 1137 , 803 , 1100 , 604 , 521 , 902 , 482 , 410 , 630 , 420 , 879 , 485 , 623 , 976 , 882 , 484 , 384 , 590 , 369 , 350 , 129 , 1603 , 320 , 100000 , 872 , 699 , 197 , 358 , 957 , 529 , 881 , 1263 , 660 , 1849 , 645 , 240 , 1250 , 631 , 1802 , 1867 , 1650 , 923 , 341 } ,
 { 1698 , 1441 , 604 , 2085 , 665 , 1255 , 1181 , 1347 , 482 , 652 , 1763 , 1188 , 952 , 1087 , 1111 , 1726 , 1333 , 1152 , 1643 , 1716 , 968 , 1024 , 326 , 1241 , 736 , 949 , 2339 , 919 , 872 , 100000 , 1511 , 815 , 669 , 1092 , 1397 , 1019 , 1982 , 1010 , 2708 , 695 , 1061 , 2089 , 1148 , 2594 , 2734 , 2520 , 1212 , 1176 } ,
 { 983 , 812 , 907 , 742 , 862 , 1123 , 731 , 985 , 1104 , 939 , 642 , 355 , 605 , 630 , 862 , 700 , 235 , 543 , 1157 , 214 , 1056 , 511 , 1191 , 413 , 792 , 708 , 1524 , 605 , 699 , 1511 , 100000 , 697 , 1051 , 1018 , 290 , 985 , 1280 , 743 , 1427 , 996 , 466 , 987 , 1110 , 1584 , 1395 , 1166 , 861 , 626 } ,
 { 1119 , 848 , 214 , 1309 , 182 , 943 , 627 , 916 , 455 , 340 , 1032 , 397 , 238 , 459 , 617 , 1023 , 525 , 470 , 1169 , 902 , 665 , 251 , 499 , 473 , 161 , 325 , 1780 , 154 , 197 , 815 , 697 , 100000 , 469 , 761 , 607 , 685 , 1446 , 472 , 1969 , 457 , 254 , 1393 , 823 , 1963 , 1975 , 1752 , 739 , 515 } ,
 { 1029 , 776 , 424 , 1479 , 312 , 1359 , 1086 , 1361 , 630 , 649 , 1131 , 833 , 706 , 924 , 443 , 1082 , 827 , 939 , 983 , 1222 , 318 , 712 , 504 , 680 , 547 , 355 , 1673 , 623 , 358 , 669 , 1051 , 469 , 100000 , 1171 , 847 , 1089 , 1316 , 919 , 2063 , 776 , 598 , 1434 , 507 , 1926 , 2101 , 1898 , 1187 , 548 } ,
 { 1815 , 1560 , 748 , 1760 , 864 , 188 , 292 , 260 , 641 , 533 , 1604 , 713 , 570 , 405 , 1374 , 1631 , 1022 , 482 , 1905 , 1210 , 1420 , 646 , 838 , 1097 , 632 , 1081 , 2421 , 652 , 957 , 1092 , 1018 , 761 , 1171 , 100000 , 1144 , 83 , 2145 , 317 , 2445 , 426 , 875 , 1972 , 1584 , 2571 , 2408 , 2179 , 194 , 1231 } ,
 { 721 , 526 , 817 , 703 , 732 , 1282 , 883 , 1171 , 1058 , 918 , 463 , 432 , 622 , 739 , 586 , 488 , 123 , 669 , 878 , 390 , 794 , 525 , 1098 , 166 , 745 , 492 , 1315 , 580 , 529 , 1397 , 290 , 607 , 847 , 1144 , 100000 , 1094 , 1036 , 836 , 1371 , 1008 , 354 , 833 , 828 , 1429 , 1369 , 1146 , 1021 , 352 } ,
 { 1753 , 1494 , 666 , 1727 , 783 , 271 , 279 , 328 , 562 , 451 , 1556 , 666 , 503 , 360 , 1299 , 1579 , 973 , 443 , 1836 , 1184 , 1341 , 585 , 758 , 1038 , 552 , 1007 , 2394 , 582 , 881 , 1019 , 985 , 685 , 1089 , 83 , 1094 , 100000 , 2083 , 259 , 2412 , 345 , 811 , 1925 , 1507 , 2523 , 2380 , 2151 , 220 , 1163 } ,
 { 330 , 598 , 1592 , 872 , 1456 , 2300 , 1906 , 2202 , 1857 , 1783 , 663 , 1453 , 1581 , 1749 , 887 , 586 , 1155 , 1690 , 346 , 1225 , 1017 , 1499 , 1794 , 1049 , 1607 , 1137 , 357 , 1508 , 1263 , 1982 , 1280 , 1446 , 1316 , 2145 , 1036 , 2083 , 100000 , 1828 , 1005 , 1903 , 1272 , 504 , 849 , 653 , 1114 , 1019 , 2044 , 932 } ,
 { 1499 , 1244 , 521 , 1479 , 608 , 483 , 178 , 445 , 528 , 362 , 1298 , 410 , 257 , 115 , 1070 , 1320 , 715 , 205 , 1590 , 949 , 1137 , 330 , 703 , 781 , 375 , 779 , 2136 , 344 , 660 , 1010 , 743 , 472 , 919 , 317 , 836 , 259 , 1828 , 100000 , 2165 , 330 , 559 , 1668 , 1291 , 2264 , 2138 , 1908 , 268 , 917 } ,
 { 1107 , 1304 , 2172 , 686 , 2066 , 2540 , 2156 , 2385 , 2425 , 2290 , 947 , 1758 , 1985 , 2055 , 1633 , 982 , 1475 , 1969 , 1286 , 1239 , 1836 , 1885 , 2439 , 1497 , 2115 , 1759 , 825 , 1950 , 1849 , 2708 , 1427 , 1969 , 2063 , 2445 , 1371 , 2412 , 1005 , 2165 , 100000 , 2377 , 1723 , 636 , 1720 , 534 , 145 , 290 , 2281 , 1531 } ,
 { 1576 , 1306 , 356 , 1698 , 491 , 609 , 490 , 665 , 220 , 130 , 1461 , 642 , 396 , 428 , 1057 , 1463 , 902 , 510 , 1621 , 1210 , 1056 , 495 , 414 , 905 , 296 , 774 , 2237 , 429 , 645 , 695 , 996 , 457 , 776 , 426 , 1008 , 345 , 1903 , 330 , 2377 , 100000 , 667 , 1829 , 1235 , 2410 , 2367 , 2139 , 519 , 972 } ,
 { 942 , 685 , 467 , 1057 , 400 , 1038 , 662 , 966 , 704 , 568 , 795 , 262 , 309 , 492 , 547 , 796 , 273 , 455 , 1034 , 660 , 679 , 231 , 751 , 238 , 392 , 291 , 1589 , 242 , 240 , 1061 , 466 , 254 , 598 , 875 , 354 , 811 , 1272 , 559 , 1723 , 667 , 100000 , 1162 , 792 , 1744 , 1724 , 1500 , 796 , 361 } ,
 { 484 , 668 , 1583 , 387 , 1466 , 2099 , 1699 , 1969 , 1845 , 1727 , 371 , 1260 , 1453 , 1568 , 999 , 371 , 953 , 1492 , 689 , 863 , 1200 , 1356 , 1837 , 925 , 1547 , 1148 , 579 , 1402 , 1250 , 2089 , 987 , 1393 , 1434 , 1972 , 833 , 1925 , 504 , 1668 , 636 , 1829 , 1162 , 100000 , 1087 , 600 , 701 , 550 , 1835 , 917 } ,
 { 617 , 444 , 882 , 1252 , 744 , 1766 , 1430 , 1729 , 1122 , 1105 , 882 , 1051 , 1039 , 1256 , 252 , 802 , 882 , 1238 , 503 , 1207 , 189 , 999 , 1011 , 702 , 959 , 516 , 1204 , 949 , 631 , 1148 , 1110 , 823 , 507 , 1584 , 828 , 1507 , 849 , 1291 , 1720 , 1235 , 792 , 1087 , 100000 , 1490 , 1787 , 1614 , 1553 , 486 } ,
 { 896 , 1157 , 2139 , 904 , 2013 , 2699 , 2300 , 2568 , 2405 , 2301 , 967 , 1858 , 2043 , 2166 , 1483 , 949 , 1550 , 2091 , 995 , 1446 , 1645 , 1949 , 2374 , 1506 , 2121 , 1688 , 347 , 1986 , 1802 , 2594 , 1584 , 1963 , 1926 , 2571 , 1429 , 2523 , 653 , 2264 , 534 , 2410 , 1744 , 600 , 1490 , 100000 , 678 , 727 , 2435 , 1461 } ,
 { 1184 , 1359 , 2182 , 668 , 2082 , 2493 , 2117 , 2333 , 2428 , 2285 , 973 , 1737 , 1972 , 2026 , 1681 , 1021 , 1467 , 1938 , 1376 , 1197 , 1891 , 1872 , 2455 , 1506 , 2114 , 1785 , 959 , 1943 , 1867 , 2734 , 1395 , 1975 , 2101 , 2408 , 1369 , 2380 , 1114 , 2138 , 145 , 2367 , 1724 , 701 , 1787 , 678 , 100000 , 229 , 2238 , 1560 } ,
 { 1030 , 1176 , 1961 , 443 , 1865 , 2266 , 1888 , 2108 , 2204 , 2059 , 768 , 1508 , 1744 , 1796 , 1489 , 826 , 1240 , 1709 , 1239 , 969 , 1704 , 1644 , 2237 , 1287 , 1890 , 1573 , 940 , 1717 , 1650 , 2520 , 1166 , 1752 , 1898 , 2179 , 1146 , 2151 , 1019 , 1908 , 290 , 2139 , 1500 , 550 , 1614 , 727 , 229 , 100000 , 2010 , 1353 } ,
 { 1718 , 1475 , 781 , 1600 , 875 , 264 , 138 , 177 , 738 , 595 , 1472 , 592 , 514 , 303 , 1326 , 1508 , 898 , 354 , 1828 , 1042 , 1403 , 567 , 928 , 998 , 641 , 1038 , 2336 , 603 , 923 , 1212 , 861 , 739 , 1187 , 194 , 1021 , 220 , 2044 , 268 , 2281 , 519 , 796 , 1835 , 1553 , 2435 , 2238 , 2010 , 100000 , 1157 } ,
 { 604 , 335 , 678 , 930 , 552 , 1398 , 1023 , 1327 , 945 , 853 , 588 , 598 , 661 , 853 , 236 , 550 , 396 , 813 , 674 , 741 , 442 , 591 , 921 , 216 , 676 , 231 , 1266 , 582 , 341 , 1176 , 626 , 515 , 548 , 1231 , 352 , 1163 , 932 , 917 , 1531 , 972 , 361 , 917 , 486 , 1461 , 1560 , 1353 , 1157 , 100000 }
};

// vector dblVR1 of size [48]
LukFiBlock::LukFiFunction::dblVR1 s21 =  { 22 , 53 , 64 , 15 , 66 , 37 , 16 ,23 , 67 , 18 , 52 ,
 69 , 17 , 29 , 50 , 13 , 95 , 34 , 59 , 36 , 22 , 94 , 28 , 34 , 36 , 38 ,
 55 , 77 , 45 , 34 , 32 , 58 , 30 , 88 , 74 , 59 , 93 , 54 , 89 , 30 , 79 ,
 46 , 35 , 41 , 99 , 52 , 76 , 93 };

// vector dblVR1 of size [48]
LukFiBlock::LukFiFunction::dblVR1 d21 = { 61 , 67 , 24 , 84 , 13 , 86 , 89 , 46 , 48 , 50 , 74 ,
 75 , 88 , 40 , 29 , 45 , 32 , 21 , 61 , 21 , 51 , 14 , 89 , 79, 38 , 20 ,
 97 , 19 , 10 , 73 , 59 , 92 , 52 , 66 , 89 , 65 , 63 , 47 , 7 , 61 , 87 ,
 19 , 36 , 43 , 9 , 12 , 8 , 67 };


/*--------------------------------------------------------------------------*/
/*------------------------------ MACROS ------------------------------------*/
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/*----------------------------- FUNCTIONS ----------------------------------*/
/*--------------------------------------------------------------------------*/

template< typename T>
static void read_T( istream & iStrm , T & t )
{
 iStrm >> eatcomments;

 int c = iStrm.peek();

 switch( c ) {
  case 'I' :
  case 'i' : t = Inf< T >();
             break;
  case '-' : iStrm.get();
             read_T( iStrm , t );
             t = - t;
             return;
  case 'M' :
  case 'm' : t = -Inf< T >();
             break;
  default :  iStrm >> t;
             return;
  }

 do { c = iStrm.get(); c = iStrm.peek();
  } while( ( c != iStrm.widen( ' ' ) ) &&
	   ( c != iStrm.widen( '\n' ) ) &&
	   ( c != iStrm.widen( '\t' ) ) );
 }

/*--------------------------------------------------------------------------*/

static inline int read_int( istream & iStrm )
{
 int d;
 read_T( iStrm , d );
 return( d );
 }

/*--------------------------------------------------------------------------*/

static inline double read_dbl( istream & iStrm )
{
 double d;
 read_T( iStrm , d );
 return( d );
 }

/*--------------------------------------------------------------------------*/

static inline string read_string( istream & iStrm )
{
 iStrm >> eatcomments;
 string s;
 int c = iStrm.peek();
 iStrm >> s;
 return( s );
 }

/*--------------------------------------------------------------------------*/
/*----------------------------- STATIC MEMBERS -----------------------------*/
/*--------------------------------------------------------------------------*/

// define and initialize here the vector of int parameters names
const std::vector< std::string > LukFiBlock::LukFiFunction::int_pars_str =
             { "intNrCmp" , "intseed" };

// define and initialize here the default int parameters
const std::vector< int > LukFiBlock::LukFiFunction::dflt_int_par =
        {    1,   // intNrCmp
	     0    // intseed
        };

// define and initialize here the map for int parameters names
const std::map< std::string , LukFiBlock::LukFiFunction::idx_type >
   LukFiBlock::LukFiFunction::int_pars_map =
            { { "intNrCmp" , LukFiBlock::LukFiFunction::intNrCmp } ,
			  { "intseed" , LukFiBlock::LukFiFunction::intseed }
			};

/*--------------------------------------------------------------------------*/

// register LukFiBlock to the Block factory
SMSpp_insert_in_factory_cpp_1( LukFiBlock );

/*--------------------------------------------------------------------------*/
/*-------------------------- OTHER INITIALIZATIONS -------------------------*/
/*--------------------------------------------------------------------------*/

void LukFiBlock::generate_abstract_variables( Configuration * stvv )
{
 if( AR & HasVar )  // the variables are there already
  return;           // nothing to do

 for( auto & var : x )
  var.set_Block( this );

 add_static_variable( x );
 AR |= HasVar;

 }  // end( LukFiBlock::generate_abstract_variables )  - - - - - - - - - - - -

/*--------------------------------------------------------------------------*/

void LukFiBlock::generate_objective( Configuration * objc )
{
 if( AR & HasObj )  // the objective is there already
  return;           // cowardly (and silently) return

 LukFiFunction::v_col_var vars( x.size() );
 for( decltype( x.size() ) i = 0 ; i < x.size() ; ++i )
  vars[ i ] = &x[ i ];

 f.set_function( new LukFiFunction( NameF , std::move( vars ) ) , eNoMod );
 //f.set_Block( this );
 set_objective( & f , eNoMod );

 AR |= HasObj;

 } // end( LukFiBlock::generate_objective )  - - - - - - - - - - - - - - - - -

/*--------------------------------------------------------------------------*/

void LukFiBlock::print( std::ostream & output , char vlvl ) const
{
 output << "LukFiBlock with " << x.size() << " vars " << std::endl;
 }

/*--------------------------------------------------------------------------*/

void LukFiBlock::load( std::istream & input , char frmt )
{
 if( x.size() )
  throw( std::logic_error( "loading a non-empty LukFiBlock" ) );

 NameF = read_int( input );
  if( NameF < 1 || NameF > 29 )
   throw( std::invalid_argument( "invalid name of function" ) );

 int n = read_int( input );
 if( n < 0 )
  throw( std::invalid_argument( "invalid number of variables" ) );

 SetDimension( n );

 // generate abstract variables  - - - - - - - - - - - - - - - - - - - - - - -

 generate_abstract_variables();
 SetInitialPoint();

 // generate abstract function  - - - - - - - - - - - - - - - - - - - - - - -

 generate_objective();

 ComputeConfig cc;
 input >> cc;
 f.get_function()->set_ComputeConfig( & cc );

 // issue the NBModification - - - - - - - - - - - - - - - - - - - - - - - -

 if( anyone_there() )
  add_Modification( std::make_shared< NBModification >( this ) );

 }  // end( LukFiBlock::load )

/*--------------------------------------------------------------------------*/

void LukFiBlock::serialize( netCDF::NcGroup & group ) const
{
 group.putAtt( "type" , "LukFiBlock" );

 // dimensions and variable declarations
 netCDF::NcDim ndim = group.addDim( "num_vars" , x.size() );

 auto cmp_cnf = f.get_function()->get_ComputeConfig();
 netCDF::NcGroup sg_f = group.addGroup( "lukfi_config" );
 cmp_cnf->serialize( sg_f );

 }  // end( LukFiBlock::serialize )

/*--------------------------------------------------------------------------*/

void LukFiBlock::deserialize( const netCDF::NcGroup & group )
{
 netCDF::NcDim n_dim  = group.getDim( "num_vars" );
 size_t n = n_dim.getSize();

 netCDF::NcDim name_f = group.getDim( "name_f" );
 NameF = name_f.getSize();

 SetDimension( n );

 LukFiFunction::v_col_var vars( x.size() );
 for( size_t i = 0 ; i < n ; i++ ) {
  x[ i ].set_Block( this );
  vars[ i ] = &x[ i ];
  }

 SetInitialPoint();

 f.set_function( new LukFiFunction( NameF , std::move( vars ) ) , eNoMod );
 f.set_Block( this );

 netCDF::NcGroup sg_f = group.getGroup( "lukfi_config" );

 auto cmp_cnf = dynamic_cast< ComputeConfig * >(
		    Configuration::new_Configuration( sg_f ) );
 f.get_function()->set_ComputeConfig( cmp_cnf );
 delete cmp_cnf;

 }  // end( LukFiBlock::deserialize )  - - - - - - - - - - - - - - - - - - - -

/*--------------------------------------------------------------------------*/
/*-------------------------- PRIVATE METHODS -------------------------------*/
/*--------------------------------------------------------------------------*/

void LukFiBlock::SetDimension( int n )
{
 // set the dimension of the function  - - - - - - - - - - - - - - - - - - - -
 //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   n = int (2);
   break;
  // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   n = int (2);
   break;
  // CB2 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 3 ):
   n = int (2);
   break;
  // CB3 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 4 ):
   n = int (2);
   break;
  // DEM (Demyanov/Malozemov)  - - - - - - - - - - - - - - - - - - - - - - - -
  case( 5 ):
   n = int (2);
   break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 6 ):
   n = int (2);
   break;
  // LQ    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 7 ):
   n = int (2);
   break;
  // Mifflin1      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 8 ):
   n = int (2);
   break;
  // Mifflin2      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 9 ):
   n = int (2);
   break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 10 ):
   n = int (2);
   break;
  // Rosen-Suzuki    - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 11 ):
   n = int (4);
   break;
  // Shor    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 12 ):
   n = int (5);
   break;
  // Maxquad   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 13 ):
   n = int (10);
   break;
  // Maxq    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 14 ):
   n = int (20);
   break;
  // Maxl    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 15 ):
   n = int (20);
   break;
  // TR48    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 16 ):
   n = int( 48 );
   break;
  // Colville1   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 17 ):
   n = int (5);
   break;
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   n = int (5);
   break;
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   n = int (10);
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   n = int (50);
   break;
  // MXHILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 21 ):
   n = int (50);
   break;
  // L1HILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ):
   n = int (50);
   break;
  // smooth     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ):
  // AbsVal     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ):
  // MaxQR    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ):
   break;
  // Lewis   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   n = int( 2 );
   break;
  }  // end( switch )

 // initialize (static) variables and box constraints - - - - - - - - - - - -

 x.resize( n );

 }  // end( LukFiBlock::SetDimension )

/*--------------------------------------------------------------------------*/

void LukFiBlock::SetInitialPoint( void )
{
 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   x[ 0 ].set_value( -1.2 );
   x[ 1 ].set_value( 1.0 );
   break;
  // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   x[ 0 ].set_value( -1.5 ) ;
   x[ 1 ].set_value( 2.0 ) ;
   break;
  // CB2 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 3 ):
   x[ 0 ].set_value( 1 ) ;
   x[ 1 ].set_value( -0.1 ) ;
   break;
  // CB3 (Charalambous/Bandler)  - - - - - - - - - - - - - - - - - - - - - - -
  case( 4 ):
   x[ 0 ].set_value( 2 );
   x[ 1 ].set_value( 2 ) ;
   break;
  // DEM (Demyanov/Malozemov)  - - - - - - - - - - - - - - - - - - - - - - - -
  case( 5 ):
   x[ 0 ].set_value( 1 ) ;
   x[ 1 ].set_value( 1 ) ;
   break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 6 ):
   x[ 0 ].set_value( -1 ) ;
   x[ 1 ].set_value( 5) ;
   break;
  // LQ    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 7 ):
   x[ 0 ].set_value( -0.5 ) ;
   x[ 1 ].set_value( -0.5 ) ;
   break;
  // Mifflin1      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 8 ):
   x[ 0 ].set_value( 0.8 ) ;
   x[ 1 ].set_value( 0.6 ) ;
   break;
  // Mifflin2      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 9 ):
   x[ 0 ].set_value( -1) ;
   x[ 1 ].set_value( -1 ) ;
   break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 10 ):
   x[ 0 ].set_value( 3 );
   x[ 1 ].set_value( 2 );
   break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 11 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
	x[ i ].set_value( 0 );
   break;
  // Shor    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 12 ):
   x[ 0 ].set_value( 0 );  x[ 1 ].set_value( 0 );  x[ 2 ].set_value( 0 );
   x[ 3 ].set_value( 0 );  x[ 4 ].set_value( 1 );
   break;
  // Maxquad   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 13 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( 1 );
   break;
  // Maxq    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 14 ):
   for( decltype( x.size() ) i = 0 ; i < 10 ; i++ )
    x[ i ].set_value( i + 1 );
   for( decltype( x.size() ) i = 10 ; i < 20 ; i++ )
    x[ i ].set_value( -i - 1 );
   break;
  // Maxl    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 15 ):
   for( decltype( x.size() ) i = 0 ; i < 10 ; i++ )
    x[ i ].set_value( i + 1 );
   for( decltype( x.size() ) i = 10 ; i < 20 ; i++ )
    x[ i ].set_value( -i - 1 );
   break;
  // TR48    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 16 ):
   // for( int i = 0 ; i < x.size() ; i++ )
   // x[ i ].set_value( 0 );
   x[0].set_value( 11.19 ); x[1].set_value( 127.2 );
   x[2].set_value( -129.7 ); x[3].set_value( 344.5 );
   x[4].set_value( -40.72 ); x[5].set_value( -295.3 );
   x[6].set_value( -202.3 ); x[7].set_value( -382.3 );
   x[8].set_value( -217.7 ); x[9].set_value( -307.7 );
   x[10].set_value( 178.1 ); x[11].set_value( -4.36 );
   x[12].set_value( -123.3 ); x[13].set_value( -265.3 );
   x[14].set_value( 28.28 ); x[15].set_value( 70.57 );
   x[16].set_value( -31.81 ); x[17].set_value( -222.3 );
   x[18].set_value( 96.19 ); x[19].set_value( -52.79 );
   x[20].set_value( -34.71 ); x[21].set_value( -59.16 );
   x[22].set_value( -373.7 ); x[23].set_value( -28.35 );
   x[24].set_value( -141.7 ); x[25].set_value( 2.28 );
   x[26].set_value( 198.5 ); x[27].set_value( -69.16 );
   x[28].set_value( -26.35 ); x[29].set_value( -88.72 );
   x[30].set_value( 130.8 ); x[31].set_value( -12.35 );
   x[32].set_value( -30.7 ); x[33].set_value( -376.3 );
   x[34].set_value( 23.18 ); x[35].set_value( -400.3 );
   x[36].set_value( 197.1 ); x[37].set_value( -260.3 );
   x[38].set_value( 813.5 ); x[39].set_value( -191.7 );
   x[40].set_value( 31.29 ); x[41].set_value( 345.5 );
   x[42].set_value( -7.72 ); x[43].set_value( 335.5 );
   x[44].set_value( 947.5 ); x[45].set_value( 722.5 );
   x[46].set_value( -300.3 ); x[47].set_value( 73.2 );
   break;
  // Colville1   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 17 ):
   x[ 0 ].set_value( 0 );  x[ 1 ].set_value( 0 );  x[ 2 ].set_value( 0 );
   x[ 3 ].set_value( 0 );  x[ 4 ].set_value( 1 );
   break;
  // HS78    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   x[ 0 ].set_value( -2 );  x[ 1 ].set_value( 1.5 );  x[ 2 ].set_value( 2 );
   x[ 3 ].set_value( -1 );  x[ 4 ].set_value( -1 );
   break;
  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( -0.1 );
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( double( i+1 ) - 25.5 );
   break;
  // MXHILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 21 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( 1 );
   break;
  // L1HILB    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 22 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( 1 );
   break;
  // smooth    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( 1.0 );
   break;
  // AbsVal    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( -1.0 );
   break;
  // MaxQR    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ):
   for( decltype( x.size() ) i = 0 ; i < x.size() ; i++ )
    x[ i ].set_value( 1.0 );
   break;
  // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   x[ 0 ].set_value( -10 ); x[ 1 ].set_value( -10 );
   break;
  }  // end( switch )
 }  // end( LukFiBlock::SetInitialPoint )

/*--------------------------------------------------------------------------*/

LukFiBlock::LukFiFunction::LukFiFunction( int name , v_col_var && vars )
 :  C05Function() , v_vars( std::move( vars ) )
{
 NameF = name;

 NrCmp = get_dflt_int_par( intNrCmp );
 seed = get_dflt_int_par( intseed );
 GPMaxSz = get_dflt_int_par( intGPMaxSz );

 bQR.clear(); aQR.clear(); cQR.clear();
 FiVal = Inf< double >();

 } // end ( LukFiFunction::LukFiFunction )

/*--------------------------------------------------------------------------*/

void LukFiBlock::LukFiFunction::set_par( idx_type par , int value )
{
 switch( par ) {
  case( intGPMaxSz ):
   GPMaxSz = value;
   break;
  case( intNrCmp ):
   NrCmp = value;
   break;
  case( intseed ):
   seed = value;
   break;
  default:
   C05Function::set_par( par , value );
  }
 } // end ( LukFiFunction::set_par( int ) )

/*--------------------------------------------------------------------------*/

int LukFiBlock::LukFiFunction::compute( bool changedvars )
{
 FiVal = 0;      // value of Fi()
 dblVR1 FiVal_, tempL;

 dblVR3 A16( 5 , dblVR2( 10 , dblVR1( 10 , 0 ) ) );
 dblVR2 b16( 5 , dblVR1( 10 , 0 ) );

 dblVR1 x( v_vars.size() );
 for( decltype( v_vars.size() ) i = 0 ; i < v_vars.size() ; i++ )
  x[ i ] = v_vars[ i ]->get_value();

 switch( NameF ) {
  // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 1 ):
   FiVal = double(100) * ( x[1] - x[0] * x[0] ) *
     ( x[1] - x[0] * x[0] )
	 + ( double(1) - x[0] ) * ( double(1) - x[0] );
   break;
  // Crescent  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 2 ):
   FiVal = std::max( x[0] * x[0] + ( x[1] - double(1) )
	 * ( x[1] - double(1) ) + x[1] - double(1) ,
     - x[0] * x[0] - ( x[1] - double(1) )
     * ( x[1] - double(1) ) +  x[1] + double(1) );
   break;
  // CB2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 3 ):
   FiVal_.resize(3);
   FiVal_[0] = x[0] * x[0] + std::pow( double(x[1]) , 4 );
   FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
     + ( double(2) - x[1] ) * ( double(2) - x[1] );
   FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // CB3 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 4 ):
   FiVal_.resize(3);
   FiVal_[0] = std::pow( x[0] , 4 ) + x[1] * x[1];
   FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
	 + ( double(2) - x[1] ) * ( double(2) - x[1] );
   FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // DEM - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 5 ):
   FiVal_.resize(3);
   FiVal_[0] = double(5) * x[0] + x[1];
   FiVal_[1] = - double(5) * x[0] + x[1];
   FiVal_[2] = x[0] * x[0] + x[1] * x[1]
	 + double(4) * x[1];
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // QL  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 6 ):
   FiVal_.resize(3);
   FiVal_[0] = x[0] * x[0]  + x[1] * x[1];
   FiVal_[1] = FiVal_[0]
	 + double(10) * ( - double(4) * x[0] - x[1] + double(4) );
   FiVal_[2] = FiVal_[0]
     + double(10) * ( - x[0] - double(2) * x[1] + double(6) );
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // LQ  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 7 ):
   FiVal = std::max( - x[0] - x[1] ,
		   - x[0] - x[1]
     + x[0] * x[0]
	 + x[1] * x[1] - double(1) );
   break;
  // Mifflin 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 8 ):
   FiVal =  - x[0]
     + double(20) * std::max( x[0] * x[0]
	 + x[1] * x[1] - double(1) , double(0) );
   break;
  // Mifflin 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 9 ):
   FiVal = - x[0] + double(2) * ( x[0]
	 * x[0] + x[1]
     * x[1] - double(1) )
	 + double(1.75) * std::abs( x[0] * x[0]
     + x[1] * x[1]  - double(1) );
   break;
  // Wolfe - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 10 ):
   if( x[0] >= std::abs( x[1] ) )
	FiVal = double(5) * std::sqrt( double(9)
	  * x[0] * x[0]
	  + double(16) * x[1] * x[1] );
   else
    if( x[0] < std::abs( x[1] ) && x[0] > double(0) )
     FiVal = double(9) * x[0] + double(16) * std::abs( x[1] );
    else
     FiVal = double(9) * x[0] + double(16) * std::abs( x[1] )
       - std::pow( x[0] , 9 );
   break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 11 ):
   FiVal_.resize(8);
   FiVal_[4] = x[0] * x[0]  + x[1] * x[1] + double(2)
	 * x[2] * x[2]
	 + x[3] * x[3] - double(5) * x[0]
	 - double(5) * x[1] - double(21) * x[2]
	 + double(7) * x[3];
   FiVal_[5] = x[0] * x[0]
     + x[1] * x[1] +  x[2]
	 * x[2] + x[3] * x[3]
	 + x[0] - x[1] + x[2]
     - x[3] - double(8);
   FiVal_[6] = x[0] * x[0] + double(2) * x[1] * x[1]
	 + x[2] * x[2]
	 + double(2) * x[3] * x[3] - x[0]
	 - x[3] - double(10);
   FiVal_[7] = x[0] * x[0]
	 + x[1] * x[1] +  x[2]
	 * x[2] + double(2) * x[0]
	 - x[1] - x[3] - double(5);
   FiVal_[0] = FiVal_[4];
   FiVal_[1] = FiVal_[4] + double(10) * FiVal_[5];
   FiVal_[2] = FiVal_[4] + double(10) * FiVal_[6];
   FiVal_[3] = FiVal_[4] + double(10) * FiVal_[7];
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.begin() + 4 );
   break;
  // Shor  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 12 ):
   FiVal_.resize(10);
   for ( Index i = 0; i < 10; i++ ) {
    FiVal_[i] = 0;
    for ( Index j = 0; j < 5; j++ )
     FiVal_[i] += b12[ i ] * ( x[ j ] - A12[ i ][ j ] )
       * ( x[ j ] - A12[ i ][ j ] );
    }
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // Maxquad - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 13 ):
   for( Index i = 1; i <= 5 ; i ++ )
    for( Index j = 1; j <= 10 ; j++ ) {
     for( Index k = j + 1; k <= 10; k++ ) {
	  A16[ i -1 ][ j -1  ][ k - 1 ] = exp( double( j ) / double( k ) )
		        * cos( j * k ) * sin( i );
      A16[ i - 1 ][ k - 1 ][ j - 1 ] = A16[ i -1 ][ j -1  ][ k - 1 ];
	  }
	 A16[ i - 1 ][ j - 1 ][ j - 1 ] = ( double( j ) / double( 10 ) )
		       * std::abs( sin( i ) );
	 for( Index k = 1; k <= 10; k++ )
	  if( j != k )
	   A16[ i - 1 ][ j - 1 ][ j - 1 ] += std::abs( A16[ i - 1 ][ j - 1 ][ k - 1 ] );
	 }
   for( Index i = 1; i <= 5; i++ )
    for( Index j = 1; j <= 10; j++ )
	 b16[ i - 1 ][ j - 1 ] = exp( double( j ) / double(i) ) * sin( i * j );
   //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   FiVal_.resize(5);
   for( Index i = 0; i < 5 ; i++ ) {
    FiVal_[i] = 0;
    for( Index k = 0; k < 10; k++ )
     FiVal_[i] += x[ k ] * std::inner_product( A16[ i ][ k ].begin(),
     A16[ i ][ k ].end() , x.begin() , double(0) );
    FiVal_[i] -= std::inner_product( b16[ i ].begin() , b16[ i ].end() , x.begin() , double(0) );
    }
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // Maxq  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 14 ):
   FiVal_.resize(20);
   for( Index i = 0; i < 20; i++ )
    FiVal_[ i ] = x[ i ] * x[ i ];
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // Maxl  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 15 ):
   FiVal_.resize(20);
   for( Index i = 0; i < 20; i++ )
    FiVal_[ i ] = std::abs( x[ i ] );
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
  // TR48  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 16 ):
   FiVal_.resize(48);
   for( Index j = 0; j < 48 ; j++ ) {
    for( Index i = 0; i < 48; i++ )
     FiVal_[ i ] = x[ i ] - A21[ i ][ j ];
    FiVal += *std::max_element( FiVal_.begin() , FiVal_.end() ) * d21[ j ];
    }
   FiVal -= std::inner_product( s21.begin() , s21.end() , x.begin() ,
				double(0) );
   break;

  // Colville 1  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 17 ):
   FiVal = std::inner_product( e13.begin() , e13.end() , x.begin() , double(0) );
   for ( Index j = 0; j < 5; j++)
    FiVal += d13[j] * x[j] * x[j] * x[j];
   for ( Index i = 0; i < 5; i++)
    FiVal += x[i] * std::inner_product( C13[ i ].begin() ,
     C13[ i ].end() , x.begin() , double(0) );
   FiVal_.resize(10);
   for ( Index i = 0; i < 10; i++ )
    FiVal_[i] = b13[i] - std::inner_product( A13[ i ].begin() , A13[ i ].end() , x.begin() , double(0) );
   FiVal += double(50) * std::max( double(0) , *std::max_element( FiVal_.begin() , FiVal_.end() ) );
   break;

  // HS78 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 18 ):
   FiVal_.resize( 3 );
   FiVal_[ 0 ] = x[ 0 ] * x[ 0 ] + x[ 1 ] * x[ 1 ] + x[ 2 ] * x[ 2 ]
               + x[ 3 ] * x[ 3 ] + x[ 4 ] * x[ 4 ]  - double( 10 );
   FiVal_[ 1 ] = x[ 1 ] * x[ 2 ] - double( 5 ) * x[ 3 ] * x[ 4 ];
   FiVal_[ 2 ] = x[ 0 ] * x[ 0 ] * x[ 0 ] + x[ 1 ] * x[ 1 ] * x[ 1 ]
               + double( 1 ) ;
   FiVal = double( 10 ) * ( std::abs( FiVal_[ 0 ] ) + std::abs( FiVal_[ 1 ] )
			    + std::abs( FiVal_[ 2 ] ) );
   FiVal += x[ 0 ] * x[ 1 ] * x[ 2 ] * x[ 3 ] * x[ 4 ] ;
   break;

  // Gill  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 19 ):
   FiVal_.resize(3);
   FiVal_[0] = 0;
   for ( Index i = 0; i < x.size(); i++ )
    FiVal_[0] += ( x[i] - double(1) ) * ( x[i] - double(1) ) +
                1e-3 * ( x[i] * x[i] - 0.25 ) *
                ( x[i] * x[i] - 0.25 );
   FiVal_[1] = x[0] * x[0] + ( x[1] - x[0] * x[0] - 1.0 )
		   * ( x[1] - x[0] * x[0] - 1.0 );
   double FiVal1;
   double FiVal2;
   for ( Index i = 1; i < 30; i++ ) {
    FiVal1 = 0;
    FiVal2 = 0;
    for( Index j = 0; j < x.size() ; j++ ) {
     FiVal2 += x[j] * ( j ) * std::pow( ( double(i) / 29) , j-1 );
     FiVal1 += x[j] * std::pow( ( double(i) / 29) , j );
     }
    FiVal2 -=  FiVal1 * FiVal1 +  double(1);
    FiVal_[1] += FiVal2 * FiVal2;
    }
   FiVal_[2] = 0;
   for( Index i = 1; i < x.size() ; i++ )
    FiVal_[2] += double(100) * ( x[i] - x[i-1] * x[i-1] ) *
      ( x[i] - x[i-1] * x[i-1] )
      + ( 1.0 - x[i] ) * ( 1.0 - x[i] );
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;

  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 20 ):
   FiVal = double(50) * *std::max_element( x.begin() , x.end() )
           - std::accumulate( x.begin() , x.end() , double( 0 ) );
   break;

  // MXHILB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 21 ):
   FiVal_.resize(x.size());
   for( Index i = 0; i < x.size(); i++ ){
	FiVal_[i] = double(0);
    for ( Index j = 0; j < x.size() ; j++ )
     FiVal_[i] += double(x[j]) / ( (i+1) + (j+1) -1 );
    FiVal_[i] = std::abs(FiVal_[i]);
	}
   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;

  // L1HILB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 22 ):
   FiVal_.resize(x.size());
   for( Index i = 0 ; i < x.size() ; i++ ) {
    FiVal_[ i ] = double( 0 );
    for ( Index j = 0 ; j < x.size() ; j++ )
     FiVal_[ i ] += double( x[ j ] ) / ( (i+1) + (j+1) -1 );
    FiVal_[ i ] = std::abs( FiVal_[ i ] );
    }
   FiVal = std::accumulate( FiVal_.begin() , FiVal_.end() , double( 0 ) );
   break;
  // smooth  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 23 ):
   for( Index i = 0; i < x.size(); i++ )
	FiVal +=  0.5 * x[ i ] *  x[ i ];
   break;
  // AbsVal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 24 ):
   for( Index i = 0; i < x.size() ; i++ )
   	FiVal += std::abs( x[ i ] );
   break;

  // MaxQR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 25 ): {
   rg.seed( seed );
   bQR.resize( NrCmp );
   aQR.resize( NrCmp );
   cQR.resize( NrCmp );

   // define data- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   std::uniform_real_distribution<> dis01( 0.0 , 1.0 );
   std::uniform_real_distribution<> dis5m5( 0.5 , - 0.5 );

   for( Index j = 0 ; j < NrCmp ; j++ ) {
    bQR[ j ] = 1e+2 * dis01( rg );
    aQR[ j ] = 2e+2 * dis5m5( rg );
    cQR[ j ].resize( v_vars.size() );
    for( decltype( v_vars.size() ) i = 0; i < v_vars.size() ; i++ )
     cQR[ j ][ i ] = 2e+2 * dis5m5( rg );
    }

   tempL.resize( x.size() , 0 );
   FiVal_.resize( NrCmp );
   for( Index j = 0; j < NrCmp; j++ ) {
    std::transform( x.begin() , x.end() , cQR[ j ].begin() , tempL.begin() ,
		    std::minus< double >() );
    FiVal_[ j ] = bQR[ j ] *  sqrt( std::inner_product( tempL.begin() ,
							tempL.end() ,
							tempL.begin() ,
							double( 0 ) ) );
    FiVal_[ j ] += aQR[ j ];
    }

   FiVal = *std::max_element( FiVal_.begin() , FiVal_.end() );
   break;
   }

  // Lewis - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 26 ):
   if( x[ 1 ] <= 0)
	FiVal = x[ 0 ] * x[ 0 ] - x[ 1 ];
   if( x[ 1 ] > 0 && x[ 1 ] < x[ 0 ] * x[ 0 ] )
	FiVal = x[ 0 ] * x[ 0 ] +  x[ 1 ];
   if( x[ 0 ] * x[ 0 ] > 0 && x[ 0 ] * x[ 0 ] <= x[ 1 ]
      && x[ 1 ] <= 4.0 * x[ 0 ] * x[ 0 ] )
	FiVal = 3.0 *  x[ 0 ] * x[ 0 ]  - x[ 1 ];
   if( x[ 1 ] > 4.0 * x[ 0 ] * x[ 0 ] )
	FiVal = - 5.0 * x[ 0 ] * x[ 0 ] + x[ 1 ];
   break;
  }

 return( FiVal );

 }  // end( LukFiFunction::compute )

/*--------------------------------------------------------------------------*/

void LukFiBlock::LukFiFunction::get_linearization_coefficients(
			     FunctionValue * g , Range range  , Index name  )
{
 range.second = std::min( range.second , get_num_active_var() );
 if( range.second <= range.first )
  return;

 if( name < Inf< Index >() )
  throw( std::logic_error( "the linearization is not available" ) );

 // auxiliary variables

 double Knst;

 Index FIndex = 0;
 dblVR1 FiVal_, tempL;

 dblVR3 A16( 5 , dblVR2( 10 , dblVR1( 10 , 0 ) ) );
 dblVR2 b16( 5 , dblVR1( 10 , 0 ) );

 dblVR1 x( v_vars.size() );
 for( decltype( v_vars.size() ) i = 0 ; i < v_vars.size() ; i++ )
  x[ i ] = v_vars[ i ]->get_value();

 // SubG is always in "dense" format
SubG.assign( x.size() , double(0) );

switch( NameF ) {
 // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 case ( 1 ):
  SubG[1] = double(200) * ( x[1] - x[0] * x[0] );
  SubG[0] = double(2) * x[0] * ( double(1) - SubG[1] ) - double(2);
  break;
 // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 case ( 2 ):
  FiVal_.resize(2);
  FiVal_[0] = x[0] * x[0]  + ( x[1] - double(1) )
		 * ( x[1] - double(1) ) + x[1] - double(1);
  FiVal_[1] = - x[0] * x[0] - ( x[1] - double(1) )
         * ( x[1] - double(1) ) +  x[1] + double(1);
  FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							     FiVal_.end() ) );
  //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (FIndex == 0) {
   SubG[0] = double(2) * x[0];
   SubG[1] = double(2) * ( x[1] - double(1) ) + double(1);
   }
  else {
   SubG[0] = - double(2) * x[0];
   SubG[1] = - double(2) * ( x[1] - double(1) ) + double(1);
   }
  break;
 // CB2   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 case ( 3 ):
  FiVal_.resize(3);
  FiVal_[0] = x[0] * x[0]
    		    + std::pow( x[1] , 4 );
  FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
	  + ( double(2) - x[1] ) * ( double(2) - x[1] );
  FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
  FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							     FiVal_.end() ) );
  //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (FIndex == 0) {
   SubG[0] = double(2) * x[0];
   SubG[1] = double(4) * std::pow( x[1] , 3 );
   }
  else
   if (FIndex == 1) {
    SubG[0] = - double(2) * ( double(2) - x[0] );
    SubG[1] = - double(2) * ( double(2) - x[1] );
    }
   else {
	SubG[0] = - double(2) * exp ( - x[0] + x[1] );
	SubG[1] = double(2) * exp ( - x[0] + x[1] );
    }
  break;
  // CB3   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 4 ):
   FiVal_.resize(3);
   FiVal_[0] = std::pow( x[0] , 4 ) + x[1] * x[1];
   FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
      + ( double(2) - x[1] ) * ( double(2) - x[1] );
   FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   if (FIndex == 0) {
    SubG[0] = double(4) * std::pow( x[0] , 3 );
    SubG[1] = double(2) * x[1];
    }
   else
    if (FIndex == 1) {
	 SubG[0] = - double(2) * ( double(2) - x[0] );
	 SubG[1] = - double(2) * ( double(2) - x[1] );
	 }
    else {
	 SubG[0] = -double(2) * exp ( - x[0] + x[1] );
	 SubG[1] = double(2) * exp ( - x[0] + x[1] );
	 }
  break;
  // DEM   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 5 ):
   FiVal_.resize(3);
   FiVal_[0] = double(5) * x[0] + x[1];
   FiVal_[1] = - double(5) * x[0] + x[1];
   FiVal_[2] = x[0] * x[0] +  x[1] * x[1]
      + double(4) * x[1];
   FIndex  = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   if (FIndex == 0) {
    SubG[0] = 5;
	SubG[1] = 1;
	}
   else
	if (FIndex == 1) {
	 SubG[0] = - 5;
	 SubG[1] = 1;
	 }
	else {
	 SubG[0] = double(2) * x[0];
	 SubG[1] = double(2) * x[1] + double(4);
	 }
  break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 6 ):
   FiVal_.resize(3);
   FiVal_[0] = x[0] * x[0] + x[1] * x[1];
   FiVal_[1] = FiVal_[0]
   	 + double(10) * ( - double(4) * x[0] - x[1] + double(4) );
   FiVal_[2] = FiVal_[0]
	  + double(10) * ( - x[0] - double(2) * x[1] + double(6) );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   SubG[0] = double(2) * x[0];
   SubG[1] = double(2) * x[1];
   if (FIndex == 1) {
    SubG[0] -= 40;
    SubG[1] -= 10;
    }
   else
    if (FIndex == 2) {
	 SubG[0] -= 10;
	 SubG[1] -= 20;
	 }
  break;
  // LQ  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 7 ):
   FiVal_.resize(2);
   FiVal_[0] = - x[0] - x[1];
   FiVal_[1] = - x[0] - x[1] + ( x[0] * x[0]
      + x[1] * x[1] - double(1) );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   SubG[0] = - 1;
   SubG[1] = - 1;
   if (FIndex == 1) {
	SubG[0] += double(2) * x[0];
	SubG[1] += double(2) * x[1];
	}
  break;
  // Mifflin 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 8 ):
   FiVal_.resize(2);
   FiVal_[0] = x[0] * x[0]
    		    + x[1] * x[1] - double(1);
   FiVal_[1] = 0;
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   SubG[0] = - 1;
   SubG[1] =  0;
   if (FIndex == 0) {
    SubG[0] += double(40) * x[0];
    SubG[1] += double(40) * x[1];
    }
  break;
  // Mifflin 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 9 ):
   FiVal_.resize(2);
   FiVal_[0] = x[0] * x[0]
    		    + x[1] * x[1] - double(1);
   FiVal_[1] = - x[0] * x[0]
    		    - x[1] * x[1] + double(1);
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   SubG[0] = -double(1) + double(4) * x[0];
   SubG[1] =  double(4) * x[1];
   if (FIndex == 0) {
    SubG[0] += double(3.5) * x[0];
    SubG[1] += double(3.5) * x[1];
    }
   else {
    SubG[0] -= double(3.5) * x[0];
    SubG[1] -= double(3.5) * x[1];
    }
   break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 10 ):
   if( x[0] >= std::abs( x[1] ) ) {
 	 SubG[0] = (x[0]==0) ? 0 : double(45) * x[0] /
	           std::sqrt( double(9) * x[0] * x[0]
  	   + double(16) * x[1] * x[1] );
     SubG[1] = (x[1]==0) ? 0 : double(80) * x[1] /
               std::sqrt( double(9) * x[0] * x[0]
			  + double(16) * x[1] * x[1] );
  	 }
   else
    if ( x[0] < std::abs( x[1] ) &&  x[0] > double(0) ) {
      SubG[0] = double(9) * x[0];
      SubG[1] = double(16) * ( x[1] >= double(0)? double(1): -double(1) );
      }
    else {
     SubG[0] = double(9) * ( double(1) - std::pow( x[0] , 8 ) );
     SubG[1] = double(16) * ( x[1] >= double(0)? double(1): -double(1) );
     }
  break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 11 ):
   FiVal_.resize(8);
   FiVal_[4] = x[0] * x[0]
    		    + x[1] * x[1] + double(2)
	 * x[2] * x[2] + x[3]
	 * x[3] - double(5) * x[0]
	 - double(5) * x[1] - double(21) * x[2]
	 + double(7) * x[3];
    FiVal_[5] = x[0] * x[0] + x[1]
    		    * x[1] +  x[2]
	  * x[2] + x[3] * x[3]
	  + x[0] - x[1] + x[2]
      - x[3] - double(8);
    FiVal_[6] = x[0] * x[0]
      + double(2) * x[1] * x[1]
	  + x[2] * x[2]
	  + double(2) * x[3] * x[3] - x[0]
	  - x[3] - double(10);
    FiVal_[7] = x[0] * x[0]
      + x[1] * x[1] +  x[2]
	  * x[2] + double(2) * x[0]
	  - x[1] - x[3] - double(5);
    FiVal_[0] = FiVal_[4];
    FiVal_[1] = FiVal_[4] + double(10) * FiVal_[5];
    FiVal_[2] = FiVal_[4] + double(10) * FiVal_[6];
    FiVal_[3] = FiVal_[4] + double(10) * FiVal_[7];
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
						       FiVal_.begin() + 4 ) );
   //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   SubG[0] = double(2) * x[0] - double(5);
   SubG[1] = double(2) * x[1] - double(5);
   SubG[2] = double(4) * x[2] - double(21);
   SubG[3] = double(2) * x[3] + double(7);
   if (FIndex == 1) {
	 SubG[0] += double(10) * ( double(2) * x[0] + double(1) );
	 SubG[1] += double(10) * ( double(2) * x[1] - double(1) );
	 SubG[2] += double(10) * ( double(2) * x[2] + double(1) );
	 SubG[3] += double(10) * ( double(2) * x[3] - double(1) );
	 }
   else
    if (FIndex == 2) {
      SubG[0] += double(10) * ( double(2) * x[0] - double(1) );
      SubG[1] += double(40) * x[1];
      SubG[2] += double(20) * x[2];
      SubG[3] += double(10) * ( double(4) * x[3] - double(1) );
	  }
	else
	 if (FIndex == 3) {
	   SubG[0] += double(10) * ( double(2) * x[0] + double(2) );
	   SubG[1] += double(10) * ( double(2) * x[1] - double(1) );
	   SubG[2] += double(20) * x[2];
	   SubG[3] -= double(10);
	   }
  break;
  // Shor  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 12 ):
   FiVal_.resize(10);
   for( Index i = 0; i < 10; i++ ) {
     FiVal_[i] = 0;
     for( Index j = 0; j < 5; j++ )
      FiVal_[i] += b12[ i ] * ( x[ j ] - A12[ i ][ j ] )
        * ( x[ j ] - A12[ i ][ j ] );
     }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    for ( Index j = 0; j < 5; j++ )
     SubG[j] = double(2) * b12[ FIndex ] * ( x[j] - A12[ FIndex ][ j ] );
    break;
  // Maxquad - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 13 ):
    for( Index i = 1; i <= 5 ; i ++ )
     for( Index j = 1; j <= 10 ; j++ ) {
      for( Index k = j + 1; k <= 10; k++ ) {
       A16[ i -1 ][ j -1  ][ k - 1 ] = exp( double( j ) / double( k ) )
         * cos( j * k ) * sin( i );
       A16[ i - 1 ][ k - 1 ][ j - 1 ] = A16[ i -1 ][ j -1  ][ k - 1 ];
       }
      A16[ i - 1 ][ j - 1 ][ j - 1 ] = ( double( j ) / double( 10 ) )
        * std::abs( sin( i ) );
      for( Index k = 1; k <= 10; k++ )
       if( j != k )
        A16[ i - 1 ][ j - 1 ][ j - 1 ] += std::abs( A16[ i - 1 ][ j - 1 ][ k - 1 ] );
      }
    for( Index i = 1; i <= 5; i++ )
     for( Index j = 1; j <= 10; j++ )
      b16[ i - 1 ][ j - 1 ] = exp( double( j ) / double(i) ) * sin( i * j );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    FiVal_.resize(5);
    for( Index i = 0; i < 5 ; i++ ) {
     FiVal_[i] = 0;
     for( Index k = 0; k < 10; k++ )
       FiVal_[i] += x[ k ] * std::inner_product( A16[ i ][ k ].begin(),
        A16[ i ][ k ].end() , x.begin() , double(0) );
      FiVal_[i] -= std::inner_product( b16[ i ].begin() , b16[ i ].end() ,
				       x.begin() , double(0) );
     }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for ( Index k = 0; k < 10 ; k ++ )
     SubG[k] = double( 2 ) * std::inner_product( A16[ FIndex ][ k ].begin() ,
    	A16[ FIndex ][ k ].end() , x.begin() , double(0) ) - b16[ FIndex ][ k ];
  break;
  // Maxq  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 14 ):
    FiVal_.resize(20);
    for( Index i = 0; i < 20; i++ )
     FiVal_[i] = x[i] * x[i];
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    SubG[ FIndex ] = double(2) * x[ FIndex ];
  break;
  // Maxl  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 15 ):
    FiVal_.resize(20);
    for ( Index i = 0; i < 20; i++ )
     FiVal_[ i ] = std::abs( x[ i ] );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    SubG[FIndex] = ( x[FIndex] >= double(0) )? double(1): - double(1);
  break;
  // TR48  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 16 ):
    FiVal_.resize(48);
    for( Index j = 0; j < 48; j++ ) {
     for( Index i = 0; i < 48 ; i++ )
      FiVal_[ i ] = x[ i ] - A21[ i ][ j ];
     FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
								FiVal_.end() ) );
     SubG[ FIndex ] += d21[ j ];
     SubG[ j ] -= s21[ j ];
     }
  break;
  // Colville 1  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 17 ):
   FiVal_.resize(10);
   for( Index i = 0; i < 10; i++ )
    FiVal_[i] = b13[i] - std::inner_product( A13[ i ].begin() , A13[ i ].end() ,
                x.begin() , double(0) );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   for ( Index j = 0; j < 5; j++ )
    SubG[j] = double(3) * d13[j] * x[j] * x[j] + e13[j]
         + double(2) * std::inner_product( C13[j].begin() , C13[j].end() ,
           x.begin() , double(0) );
   if( FiVal_[FIndex] >  double(0) )
   for ( Index j = 0; j < x.size() ; j++ )
    SubG[j] += double(50) * A13[ FIndex ][ j ];
   break;
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   FiVal_.resize(3);
   FiVal_[0] = std::pow( double(x[0]) , 2 )
             + std::pow( double(x[1]) , 2 )
             + std::pow( double(x[2]) , 2 )
             + std::pow( double(x[3]) , 2 )
             + std::pow( double(x[4]) , 2 ) - double(10);
   FiVal_[1] = double(x[1]) * double(x[2])
                   - double(5) * double(x[3]) * double(x[4]);
   FiVal_[2] = std::pow( double(x[0]) , 3 ) + std::pow( double(x[1]) , 3 ) + double(1) ;
   SubG[0] = x[1] * x[2]
                        * x[3] * x[4];
   SubG[1] = x[0] * x[2]
                       * x[3] * x[4];
   SubG[2] = x[0] * x[1]
                       * x[3] * x[4];
   SubG[3] = x[0] * x[1]
                       * x[2] * x[4];
   SubG[4] = x[0] * x[1]
                       * x[2] * x[3];
   if (FiVal_[0] == std::max( FiVal_[0], -FiVal_[0])) {
    SubG[0] += double(20) * x[0];
    SubG[1] += double(20) * x[1];
    SubG[2] += double(20) * x[2];
    SubG[3] += double(20) * x[3];
    SubG[4] += double(20) * x[4];
    }
   else {
    SubG[0] -= double(20) * x[0];
    SubG[1] -= double(20) * x[1];
    SubG[2] -= double(20) * x[2];
    SubG[3] -= double(20) * x[3];
    SubG[4] -= double(20) * x[4];
    }
   if( FiVal_[1] == std::max( FiVal_[1], -FiVal_[1]) ) {
    SubG[1] += double(10) * x[2];
    SubG[2] += double(10) * x[1];
    SubG[3] -= double(50) * x[4];
    SubG[4] -= double(50) * x[3];
    }
   else {
    SubG[1] -= double(10) * x[2];
    SubG[2] -= double(10) * x[1];
    SubG[3] += double(50) * x[4];
    SubG[4] += double(50) * x[3];
    }
   if( FiVal_[2] == std::max( FiVal_[2], -FiVal_[2]) ) {
    SubG[0] += double(30) * std::pow( x[0], 2);
    SubG[1] += double(30) * std::pow( x[1], 2);
    }
   else {
    SubG[0] -= double(30) * std::pow( x[0], 2);
    SubG[1] -= double(30) * std::pow( x[1], 2);
    }
   break;
  // Gill    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   FiVal_.resize(3);
   FiVal_[0] = 0;
   for ( Index i = 0; i < x.size(); i++ )
    FiVal_[0] += std::pow( x[i] - double(1), 2 ) + 1e-3
                    * std::pow( std::pow( x[i] , 2 ) - 0.25 , 2 );
   FiVal_[1] = std::pow( x[0] , 2 ) + std::pow( x[1]
      	   	      - std::pow( x[0] , 2 ) - double(1) , 2);
   double FiVal1;
   double FiVal2;
   for( Index i = 1; i < 30; i++ ) {
    FiVal1 = 0;
    FiVal2 = 0;
    for( Index j = 0; j < x.size(); j++ ) {
     FiVal2 += x[j] * ( j ) * std::pow( ( double(i) / 29) , j-1 );
     FiVal1 += x[j] * std::pow( ( double(i) / 29) , j );
     }
    FiVal2 -=  std::pow( FiVal1 , 2 ) +  double(1);
    FiVal_[1] += std::pow( FiVal2 , 2 );
    }
   FiVal_[2] = 0;
   for( Index i = 1; i < x.size(); i++ )
    FiVal_[2] += double(100) * std::pow( x[i]
    		     - std::pow( x[i-1] , 2 ) , 2 )
                    + std::pow( double(1) - x[i] , 2 );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );

   if( FIndex == 0 )
    for( Index i = 0; i < x.size() ; i++ )
       SubG[i] = double(2) * ( x[i] - double(1) ) + 4e-3
                         * std::pow( std::pow( x[i] , 2 ) - 0.25, 2 )
                            * x[i];
   else
    if( FIndex == 1 ) {
     double GiVal1;
     for( Index i = 1; i < 30; i++ )
     for( Index j = 0; j < x.size() ; j++ ) {
     SubG[j] = 0;
     GiVal1 = 0;
     for( Index k = 0; k < x.size(); k++ ) {
      GiVal1 += x[k] * std::pow( ( double(i) / 29) , k );
      SubG[j] += x[k] * ( k ) * std::pow( ( double(i) / 29 ) , k-1 );
      }
     SubG[j] -= std::pow( GiVal1 , 2 ) +  double(1);
     SubG[j] *= double(2) * ( x[j] * ( j )
                             * std::pow( ( double(i) / 29) , j-1 ) - double(2)
                             * GiVal1 * std::pow( ( double(i) / 29 ) , j-1 ) );
     }
    SubG[0] += double(2) * x[0] - double(4) *
                    ( x[1] - std::pow( x[0] , 2 ) - double(1) )
                           * x[0];
    SubG[1] += double(2) * ( x[1] - std::pow( x[0] , 2 ) - double(1) );
    }
   else {
    for ( Index i = 1 ; i < x.size() ; i++ )
      SubG[i] += double(200) * ( x[i] - std::pow( x[i-1],2 ) )
                 + double(-2) * ( double(1) - x[i] ) - double(400)
                 * ( x[i+1] - std::pow( x[i] , 2 ) ) * x[i];
    SubG[0] += - double(400) * ( x[1] - std::pow( x[0] , 2 ) ) * x[0];
    }
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   FIndex = std::distance( x.begin() , std::max_element( x.begin() , x.end() ) );
   SubG[FIndex] = double(50);
   for ( Index i = 0; i < x.size() ; i++ )
    SubG[i] -= double(1);
   break;
  // MXHILB - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 21 ): {
   FiVal_.resize(x.size());
   dblVR1 b(x.size() , 0.0 );
   for ( Index i = 0; i < x.size(); i++ ) {
    FiVal_[i] = 0;
    for ( Index j = 0; j < x.size() ; j++ )
     FiVal_[i] += x[j] / double( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= double(0) )
     b[i] = double(1);
    else
      b[i] = -double(1);
    FiVal_[i] = std::abs(FiVal_[i]);
    }
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   for ( Index j = 0; j < x.size() ; j++ )
    SubG[j] = b[FIndex] / ( (FIndex+1) + (j+1) -1 );
   break;
   }
  // L1HILB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 22 ): {
   FiVal_.resize(x.size());
   dblVR1 b(x.size() , 0.0 );
   for( Index i = 0; i < x.size(); i++ ) {
    FiVal_[i] = double(0);
    for ( Index j = 0; j < x.size(); j++ )
     FiVal_[i] += x[j] / ( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= double(0) )
     b[i] = double(1);
    else
     b[i] = -double(1);
    }
    for ( Index i = 0; i < x.size(); i++ )
     for ( Index j = 0; j < x.size(); j++ )
      SubG[j] += b[i] / double( (i+1) + (j+1) -1 );
    break;
   }
   // smooth  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 23 ):
    for( Index i = 0; i < x.size() ; i++ )
     SubG[ i ] = x[ i ];
    break;
   // AbsVal   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 24 ):
    for( Index i = 0; i < x.size() ; i++ )
     if( x[ i ] >= 0 )
      SubG[ i ] = 1;
     else
      SubG[ i ] = -1;
    break;
   // MaxQR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 25 ) :
    tempL.resize( x.size() , 0 );
    FiVal_.resize( NrCmp );
    for( Index j = 0; j < NrCmp; j++ ) {
	 std::transform( x.begin(), x.end(), cQR[j].begin(), tempL.begin(),
			 std::minus< double >() );
	 FiVal_[ j ] = bQR[ j ] *  sqrt( std::inner_product( tempL.begin() ,
							     tempL.end() ,
							     tempL.begin() ,
							     double(0) ) );
	 FiVal_[ j ] += aQR[ j ];
	 }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    std::transform( x.begin(), x.end(), cQR[FIndex].begin(), SubG.begin(),
		    std::minus< double >() );
    Knst = 2.0 * bQR[FIndex];
    std::transform( SubG.begin(), SubG.end(), SubG.begin(),
		    [ Knst ](const auto & p1){ return( p1 * Knst ); } );
    break;
   // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 26 ):
    if( x[ 1 ] <= 0) {
     SubG[ 0 ] = 2.0 * x[ 0 ];
     SubG[ 1 ] = -1;
     }
    if( x[ 1 ] > 0 && x[ 1 ] < x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = 2.0 * x[ 0 ];
     SubG[ 1 ] = 1;
     }
    if( x[ 0 ] * x[ 0 ] > 0 && x[ 0 ] * x[ 0 ] <= x[ 1 ]
         &&  x[ 1 ] <= 4.0 * x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = 6.0 * x[ 0 ];
     SubG[ 1 ] = -1.0;
     }
    if( x[ 1 ] > 4.0 * x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = -10.0 * x[ 0 ];
     SubG[ 1 ] = 1.0;
     }
    break;
   }

 for( Index i = range.first ; i < range.second ; i++ )
  *(g++) = SubG[ i ];

 } // end( LukFiFunction::get_linearization_coefficients( range ) )

/*--------------------------------------------------------------------------*/

void LukFiBlock::LukFiFunction::get_linearization_coefficients(
	    FunctionValue * g ,
	    c_Subset & subset , bool ordered , Index name )
{
 if( name < Inf< Index >() )
  throw( std::logic_error( "the linearization is not available" ) );

 // auxiliary variables

 double Knst;

 Index FIndex = 0;
 dblVR1 FiVal_, tempL;

 dblVR3 A16( 5 , dblVR2( 10 , dblVR1( 10 , 0 ) ) );
 dblVR2 b16( 5 , dblVR1( 10 , 0 ) );

 dblVR1 x( v_vars.size() );
 for( decltype( v_vars.size() ) i = 0 ; i < v_vars.size() ; i++ )
  x[ i ] = v_vars[ i ]->get_value();

 // SubG is always in "dense" format
 SubG.assign( x.size() , 0.0 );

 switch( NameF ) {
 // Rosenbrock  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 case ( 1 ):
  SubG[1] = double(200) * ( x[1] - x[0] * x[0] );
  SubG[0] = double(2) * x[0] * ( double(1) - SubG[1] ) - double(2);
  break;
 // Crescent    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 case ( 2 ):
  FiVal_.resize(2);
  FiVal_[0] = x[0] * x[0]  + ( x[1] - double(1) )
		 * ( x[1] - double(1) ) + x[1] - double(1);
  FiVal_[1] = - x[0] * x[0] - ( x[1] - double(1) )
         * ( x[1] - double(1) ) +  x[1] + double(1);
  FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							     FiVal_.end() ) );
  //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (FIndex == 0) {
   SubG[0] = double(2) * x[0];
   SubG[1] = double(2) * ( x[1] - double(1) ) + double(1);
   }
  else {
   SubG[0] = - double(2) * x[0];
   SubG[1] = - double(2) * ( x[1] - double(1) ) + double(1);
   }
  break;
 // CB2   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 3 ):
    FiVal_.resize(3);
    FiVal_[0] = x[0] * x[0]
    		    + std::pow( x[1] , 4 );
    FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
	  + ( double(2) - x[1] ) * ( double(2) - x[1] );
    FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
     SubG[0] = double(2) * x[0];
     SubG[1] = double(4) * std::pow( x[1] , 3 );
	 }
    else
     if (FIndex == 1) {
      SubG[0] = - double(2) * ( double(2) - x[0] );
      SubG[1] = - double(2) * ( double(2) - x[1] );
	  }
	 else {
	  SubG[0] = - double(2) * exp ( - x[0] + x[1] );
	  SubG[1] = double(2) * exp ( - x[0] + x[1] );
	  }
    break;
  // CB3   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 4 ):
    FiVal_.resize(3);
    FiVal_[0] = std::pow( x[0] , 4 ) + x[1] * x[1];
    FiVal_[1] = ( double(2) - x[0] ) * ( double(2) - x[0] )
      + ( double(2) - x[1] ) * ( double(2) - x[1] );
    FiVal_[2] = double(2) * exp ( - x[0] + x[1] );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
	 SubG[0] = double(4) * std::pow( x[0] , 3 );
     SubG[1] = double(2) * x[1];
     }
    else
     if (FIndex == 1) {
	  SubG[0] = - double(2) * ( double(2) - x[0] );
	  SubG[1] = - double(2) * ( double(2) - x[1] );
	  }
     else {
	  SubG[0] = -double(2) * exp ( - x[0] + x[1] );
	  SubG[1] = double(2) * exp ( - x[0] + x[1] );
	  }
  break;
  // DEM   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 5 ):
    FiVal_.resize(3);
    FiVal_[0] = double(5) * x[0] + x[1];
    FiVal_[1] = - double(5) * x[0] + x[1];
    FiVal_[2] = x[0] * x[0] +  x[1] * x[1]
      + double(4) * x[1];
    FIndex  = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (FIndex == 0) {
	 SubG[0] = 5;
	 SubG[1] = 1;
	 }
    else
	 if (FIndex == 1) {
	  SubG[0] = - 5;
	  SubG[1] = 1;
	  }
	 else {
	  SubG[0] = double(2) * x[0];
	  SubG[1] = double(2) * x[1] + double(4);
	  }
  break;
  // QL    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 6 ):
    FiVal_.resize(3);
    FiVal_[0] = x[0] * x[0] + x[1] * x[1];
    FiVal_[1] = FiVal_[0]
   	 + double(10) * ( - double(4) * x[0] - x[1] + double(4) );
    FiVal_[2] = FiVal_[0]
	  + double(10) * ( - x[0] - double(2) * x[1] + double(6) );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = double(2) * x[0];
    SubG[1] = double(2) * x[1];
    if (FIndex == 1) {
     SubG[0] -= 40;
     SubG[1] -= 10;
     }
    else
     if (FIndex == 2) {
	  SubG[0] -= 10;
	  SubG[1] -= 20;
	  }
  break;
  // LQ  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 7 ):
    FiVal_.resize(2);
    FiVal_[0] = - x[0] - x[1];
    FiVal_[1] = - x[0] - x[1] + ( x[0] * x[0]
      + x[1] * x[1] - double(1) );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = - 1;
    SubG[1] = - 1;
    if (FIndex == 1) {
	 SubG[0] += double(2) * x[0];
	 SubG[1] += double(2) * x[1];
	 }
  break;
  // Mifflin 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 8 ):
    FiVal_.resize(2);
    FiVal_[0] = x[0] * x[0]
    		    + x[1] * x[1] - double(1);
    FiVal_[1] = 0;
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = - 1;
    SubG[1] =  0;
    if (FIndex == 0) {
     SubG[0] += double(40) * x[0];
     SubG[1] += double(40) * x[1];
     }
  break;
  // Mifflin 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 9 ):
    FiVal_.resize(2);
    FiVal_[0] = x[0] * x[0]
    		    + x[1] * x[1] - double(1);
    FiVal_[1] = - x[0] * x[0]
    		    - x[1] * x[1] + double(1);
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = -double(1) + double(4) * x[0];
    SubG[1] =  double(4) * x[1];
    if (FIndex == 0) {
     SubG[0] += double(3.5) * x[0];
     SubG[1] += double(3.5) * x[1];
     }
    else {
     SubG[0] -= double(3.5) * x[0];
     SubG[1] -= double(3.5) * x[1];
     }
  break;
  // Wolfe   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 10 ):
    if( x[0] >= std::abs( x[1] ) ) {
  	 SubG[0] = double(45) * x[0] /
	           std::sqrt( double(9) * x[0] * x[0]
  	   + double(16) * x[1] * x[1] );
     SubG[1] = double(80) * x[1] /
               std::sqrt( double(9) * x[0] * x[0]
			  + double(16) * x[1] * x[1] );
  	 }
    else
     if ( x[0] < std::abs( x[1] ) &&  x[0] > double(0) ) {
      SubG[0] = double(9) * x[0];
      SubG[1] = double(16) * ( x[1] >= double(0)? double(1): -double(1) );
      }
     else {
      SubG[0] = double(9) * ( double(1) - std::pow( x[0] , 8 ) );
      SubG[1] = double(16) * ( x[1] >= double(0)? double(1): -double(1) );
      }
  break;
  // Rosen   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 11 ):
	FiVal_.resize(8);
    FiVal_[4] = x[0] * x[0]
    		    + x[1] * x[1] + double(2)
	 * x[2] * x[2] + x[3]
	 * x[3] - double(5) * x[0]
	 - double(5) * x[1] - double(21) * x[2]
	 + double(7) * x[3];
    FiVal_[5] = x[0] * x[0] + x[1]
    		    * x[1] +  x[2]
	  * x[2] + x[3] * x[3]
	  + x[0] - x[1] + x[2]
      - x[3] - double(8);
    FiVal_[6] = x[0] * x[0]
      + double(2) * x[1] * x[1]
	  + x[2] * x[2]
	  + double(2) * x[3] * x[3] - x[0]
	  - x[3] - double(10);
    FiVal_[7] = x[0] * x[0]
      + x[1] * x[1] +  x[2]
	  * x[2] + double(2) * x[0]
	  - x[1] - x[3] - double(5);
    FiVal_[0] = FiVal_[4];
    FiVal_[1] = FiVal_[4] + double(10) * FiVal_[5];
    FiVal_[2] = FiVal_[4] + double(10) * FiVal_[6];
    FiVal_[3] = FiVal_[4] + double(10) * FiVal_[7];
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							FiVal_.begin() + 4 ) );
    //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    SubG[0] = double(2) * x[0] - double(5);
    SubG[1] = double(2) * x[1] - double(5);
    SubG[2] = double(4) * x[2] - double(21);
    SubG[3] = double(2) * x[3] + double(7);
    if (FIndex == 1) {
	 SubG[0] += double(10) * ( double(2) * x[0] + double(1) );
	 SubG[1] += double(10) * ( double(2) * x[1] - double(1) );
	 SubG[2] += double(10) * ( double(2) * x[2] + double(1) );
	 SubG[3] += double(10) * ( double(2) * x[3] - double(1) );
	 }
    else
	 if (FIndex == 2) {
      SubG[0] += double(10) * ( double(2) * x[0] - double(1) );
      SubG[1] += double(40) * x[1];
      SubG[2] += double(20) * x[2];
      SubG[3] += double(10) * ( double(4) * x[3] - double(1) );
	  }
	 else
	  if (FIndex == 3) {
	   SubG[0] += double(10) * ( double(2) * x[0] + double(2) );
	   SubG[1] += double(10) * ( double(2) * x[1] - double(1) );
	   SubG[2] += double(20) * x[2];
	   SubG[3] -= double(10);
	   }
  break;
  // Shor  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 12 ):
    FiVal_.resize(10);
    for( Index i = 0; i < 10; i++ ) {
     FiVal_[i] = 0;
     for( Index j = 0; j < 5; j++ )
      FiVal_[i] += b12[ i ] * ( x[ j ] - A12[ i ][ j ] )
        * ( x[ j ] - A12[ i ][ j ] );
     }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    for ( Index j = 0; j < 5; j++ )
     SubG[j] = double(2) * b12[ FIndex ] * ( x[j] - A12[ FIndex ][ j ] );
  break;
  // Maxquad - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 13 ):
    for( Index i = 1; i <= 5 ; i ++ )
     for( Index j = 1; j <= 10 ; j++ ) {
      for( Index k = j + 1; k <= 10; k++ ) {
       A16[ i -1 ][ j -1  ][ k - 1 ] = exp( double( j ) / double( k ) )
         * cos( j * k ) * sin( i );
       A16[ i - 1 ][ k - 1 ][ j - 1 ] = A16[ i -1 ][ j -1  ][ k - 1 ];
       }
      A16[ i - 1 ][ j - 1 ][ j - 1 ] = ( double( j ) / double( 10 ) )
        * std::abs( sin( i ) );
      for( Index k = 1; k <= 10; k++ )
       if( j != k )
        A16[ i - 1 ][ j - 1 ][ j - 1 ] += std::abs( A16[ i - 1 ][ j - 1 ][ k - 1 ] );
      }
    for( Index i = 1; i <= 5; i++ )
     for( Index j = 1; j <= 10; j++ )
      b16[ i - 1 ][ j - 1 ] = exp( double( j ) / double(i) ) * sin( i * j );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    FiVal_.resize(5);
    for( Index i = 0; i < 5 ; i++ ) {
     FiVal_[i] = 0;
     for( Index k = 0; k < 10; k++ )
       FiVal_[i] += x[ k ] * std::inner_product( A16[ i ][ k ].begin(),
        A16[ i ][ k ].end() , x.begin() , double(0) );
      FiVal_[i] -= std::inner_product( b16[ i ].begin() , b16[ i ].end() ,
				       x.begin() , double(0) );
     }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for ( Index k = 0; k < 10 ; k ++ )
     SubG[k] = double( 2 ) * std::inner_product( A16[ FIndex ][ k ].begin() ,
    	A16[ FIndex ][ k ].end() , x.begin() , double(0) ) - b16[ FIndex ][ k ];
  break;
  // Maxq  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 14 ):
    FiVal_.resize(20);
    for( Index i = 0; i < 20; i++ )
     FiVal_[i] = x[i] * x[i];
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    SubG[ FIndex ] = double(2) * x[ FIndex ];
    break;
   // Maxl  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case ( 15 ):
    FiVal_.resize(20);
    for ( Index i = 0; i < 20; i++ )
     FiVal_[ i ] = std::abs( x[ i ] );
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    SubG[FIndex] = ( x[FIndex] >= double(0) )? double(1): - double(1);
  break;
  // TR48  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 16 ):
    FiVal_.resize(48,double(0));
    for( Index j = 0; j < 48; j++ ) {
     for( Index i = 0; i < 48 ; i++ )
      FiVal_[ i ] = x[ i ] - A21[ i ][ j ];
     FIndex = std::distance( FiVal_.begin() ,
			     std::max_element( FiVal_.begin() , FiVal_.end() )
			     );
     SubG[ FIndex ] += d21[ j ];
     SubG[ j ] -= s21[ j ];
     }
  break;
  // Colville 1  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 17 ):
   FiVal_.resize(10);
   for( Index i = 0; i < 10; i++ )
    FiVal_[i] = b13[i] - std::inner_product( A13[ i ].begin() ,
					     A13[ i ].end() , x.begin() ,
					     double(0) );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   for ( Index j = 0; j < 5; j++ )
    SubG[j] = double(3) * d13[j] * x[j] * x[j] + e13[j]
         + double(2) * std::inner_product( C13[j].begin() , C13[j].end() ,
           x.begin() , double(0) );
   if( FiVal_[FIndex] >  double(0) )
   for ( Index j = 0; j < x.size() ; j++ )
    SubG[j] += double(50) * A13[ FIndex ][ j ];
  break;
  // HS78  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 18 ):
   FiVal_.resize(3);
   FiVal_[0] = std::pow( double(x[0]) , 2 )
             + std::pow( double(x[1]) , 2 )
             + std::pow( double(x[2]) , 2 )
             + std::pow( double(x[3]) , 2 )
             + std::pow( double(x[4]) , 2 ) - double(10);
   FiVal_[1] = double(x[1]) * double(x[2])
                   - double(5) * double(x[3]) * double(x[4]);
   FiVal_[2] = std::pow( double(x[0]) , 3 ) + std::pow( double(x[1]) , 3 ) +
    double(1) ;
   SubG[0] = x[1] * x[2]
                        * x[3] * x[4];
   SubG[1] = x[0] * x[2]
                       * x[3] * x[4];
   SubG[2] = x[0] * x[1]
                       * x[3] * x[4];
   SubG[3] = x[0] * x[1]
                       * x[2] * x[4];
   SubG[4] = x[0] * x[1]
                       * x[2] * x[3];
   if (FiVal_[0] == std::max( FiVal_[0], -FiVal_[0])) {
    SubG[0] += double(20) * x[0];
    SubG[1] += double(20) * x[1];
    SubG[2] += double(20) * x[2];
    SubG[3] += double(20) * x[3];
    SubG[4] += double(20) * x[4];
    }
   else {
    SubG[0] -= double(20) * x[0];
    SubG[1] -= double(20) * x[1];
    SubG[2] -= double(20) * x[2];
    SubG[3] -= double(20) * x[3];
    SubG[4] -= double(20) * x[4];
    }
   if( FiVal_[1] == std::max( FiVal_[1], -FiVal_[1]) ) {
    SubG[1] += double(10) * x[2];
    SubG[2] += double(10) * x[1];
    SubG[3] -= double(50) * x[4];
    SubG[4] -= double(50) * x[3];
    }
   else {
    SubG[1] -= double(10) * x[2];
    SubG[2] -= double(10) * x[1];
    SubG[3] += double(50) * x[4];
    SubG[4] += double(50) * x[3];
    }
   if( FiVal_[2] == std::max( FiVal_[2], -FiVal_[2]) ) {
    SubG[0] += double(30) * std::pow( x[0], 2);
    SubG[1] += double(30) * std::pow( x[1], 2);
    }
   else {
    SubG[0] -= double(30) * std::pow( x[0], 2);
    SubG[1] -= double(30) * std::pow( x[1], 2);
    }
  break;
  // Gill    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 19 ):
   FiVal_.resize(3);
   FiVal_[0] = 0;
   for ( Index i = 0; i < x.size(); i++ )
    FiVal_[0] += std::pow( x[i] - double(1), 2 ) + 1e-3
                    * std::pow( std::pow( x[i] , 2 ) - 0.25 , 2 );
   FiVal_[1] = std::pow( x[0] , 2 ) + std::pow( x[1]
      	   	      - std::pow( x[0] , 2 ) - double(1) , 2);
   double FiVal1;
   double FiVal2;
   for( Index i = 1; i < 30; i++ ) {
    FiVal1 = 0;
    FiVal2 = 0;
    for( Index j = 0; j < x.size(); j++ ) {
     FiVal2 += x[j] * ( j ) * std::pow( ( double(i) / 29) , j-1 );
     FiVal1 += x[j] * std::pow( ( double(i) / 29) , j );
     }
    FiVal2 -=  std::pow( FiVal1 , 2 ) +  double(1);
    FiVal_[1] += std::pow( FiVal2 , 2 );
    }
   FiVal_[2] = 0;
   for( Index i = 1; i < x.size(); i++ )
    FiVal_[2] += double(100) * std::pow( x[i]
    		     - std::pow( x[i-1] , 2 ) , 2 )
                    + std::pow( double(1) - x[i] , 2 );
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );

   if( FIndex == 0 )
    for( Index i = 0; i < x.size() ; i++ )
       SubG[i] = double(2) * ( x[i] - double(1) ) + 4e-3
                         * std::pow( std::pow( x[i] , 2 ) - 0.25, 2 )
                            * x[i];
   else
    if( FIndex == 1 ) {
     double GiVal1;
     for( Index i = 1; i < 30; i++ )
     for( Index j = 0; j < x.size() ; j++ ) {
     SubG[j] = 0;
     GiVal1 = 0;
     for( Index k = 0; k < x.size(); k++ ) {
      GiVal1 += x[k] * std::pow( ( double(i) / 29) , k );
      SubG[j] += x[k] * ( k ) * std::pow( ( double(i) / 29 ) , k-1 );
      }
     SubG[j] -= std::pow( GiVal1 , 2 ) +  double(1);
     SubG[j] *= double(2) * ( x[j] * ( j )
                             * std::pow( ( double(i) / 29) , j-1 ) - double(2)
                             * GiVal1 * std::pow( ( double(i) / 29 ) , j-1 ) );
     }
    SubG[0] += double(2) * x[0] - double(4) *
                    ( x[1] - std::pow( x[0] , 2 ) - double(1) )
                           * x[0];
    SubG[1] += double(2) * ( x[1] - std::pow( x[0] , 2 ) - double(1) );
    }
   else {
    for ( Index i = 1 ; i < x.size() ; i++ )
      SubG[i] += double(200) * ( x[i] - std::pow( x[i-1],2 ) )
                 + double(-2) * ( double(1) - x[i] ) - double(400)
                 * ( x[i+1] - std::pow( x[i] , 2 ) ) * x[i];
    SubG[0] += - double(400) * ( x[1] - std::pow( x[0] , 2 ) ) * x[0];
    }
   break;
  // Goffin  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case( 20 ):
   FIndex = std::distance( x.begin() , std::max_element( x.begin() ,
							 x.end() ) );
   SubG[FIndex] = double(50);
   for ( Index i = 0; i < x.size() ; i++ )
    SubG[i] -= double(1);
   break;
  // MXHILB - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  case ( 21 ): {
   FiVal_.resize(x.size());
   dblVR1 b(x.size() , 0.0 );
   for ( Index i = 0; i < x.size(); i++ ) {
    FiVal_[i] = 0;
    for ( Index j = 0; j < x.size() ; j++ )
     FiVal_[i] += x[j] / double( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= double(0) )
     b[i] = double(1);
    else
      b[i] = -double(1);
    FiVal_[i] = std::abs(FiVal_[i]);
    }
   FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							      FiVal_.end() ) );
   for ( Index j = 0; j < x.size() ; j++ )
    SubG[j] = b[FIndex] / ( (FIndex+1) + (j+1) -1 );
   break;
   }
  // L1HILB
  case ( 22 ): {
   FiVal_.resize(x.size());
   dblVR1 b(x.size() , 0.0 );
   for( Index i = 0; i < x.size(); i++ ) {
    FiVal_[i] = double(0);
    for ( Index j = 0; j < x.size(); j++ )
     FiVal_[i] += x[j] / ( (i+1) + (j+1) -1 );
    if ( FiVal_[i] >= double(0) )
     b[i] = double(1);
    else
     b[i] = -double(1);
    }
    for ( Index i = 0; i < x.size(); i++ )
     for ( Index j = 0; j < x.size(); j++ )
      SubG[j] += b[i] / double( (i+1) + (j+1) -1 );
    break;
   }
   // smooth  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 23 ):
    for( Index i = 0; i < x.size() ; i++ )
     SubG[ i ] = x[ i ];
    break;
   // AbsVal   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 24 ):
    for( Index i = 0; i < x.size() ; i++ )
     if( x[ i ] >= 0 )
      SubG[ i ] = 1;
     else
      SubG[ i ] = -1;
    break;
   // MaxQR   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 25 ) :
    tempL.resize( x.size() , 0 );
    FiVal_.resize( NrCmp );
    for( Index j = 0; j < NrCmp; j++ ) {
	 std::transform( x.begin(), x.end(), cQR[j].begin(), tempL.begin(),
			 std::minus< double >() );
	 FiVal_[ j ] = bQR[ j ] *  sqrt( std::inner_product( tempL.begin() ,
							     tempL.end() ,
							     tempL.begin() ,
							     double(0) ) );
	 FiVal_[ j ] += aQR[ j ];
	 }
    FIndex = std::distance( FiVal_.begin() , std::max_element( FiVal_.begin() ,
							       FiVal_.end() ) );
    std::transform( x.begin(), x.end(), cQR[FIndex].begin(), SubG.begin(),
		    std::minus< double >() );
    Knst = 2.0 * bQR[FIndex];
    std::transform( SubG.begin(), SubG.end(), SubG.begin(),
		    [ Knst ](const auto & p1){ return( p1 * Knst ); } );
    break;
   // Lewis  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   case( 26 ):
    if( x[ 1 ] <= 0) {
     SubG[ 0 ] = 2.0 * x[ 0 ];
     SubG[ 1 ] = -1;
     }
    if( x[ 1 ] > 0 && x[ 1 ] < x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = 2.0 * x[ 0 ];
     SubG[ 1 ] = 1;
     }
    if( x[ 0 ] * x[ 0 ] > 0 && x[ 0 ] * x[ 0 ] <= x[ 1 ]
         &&  x[ 1 ] <= 4.0 * x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = 6.0 * x[ 0 ];
     SubG[ 1 ] = -1.0;
     }
    if( x[ 1 ] > 4.0 * x[ 0 ] * x[ 0 ] ) {
     SubG[ 0 ] = -10.0 * x[ 0 ];
     SubG[ 1 ] = 1.0;
     }
    break;
   }

 c_Index num_active_var = get_num_active_var();
 for( const auto & i : subset ) {
  if( i >= num_active_var )
   throw( std::invalid_argument( "LinearFunction::get_linearization_"
                                "coefficients: wrong index in subset: " +
                                std::to_string( i ) ) );
  *(g++) = SubG[ i ];
  }
 } // end( LukFiFunction::get_linearization_coefficients( subset ) )

/*--------------------------------------------------------------------------*/

Function::FunctionValue
          LukFiBlock::LukFiFunction::get_linearization_constant( Index name )
{

 if( name != Inf< Index >() )
  throw( std::logic_error( "the linearization is not available" ) );

 double value_k = FiVal;
 for( decltype( v_vars.size() ) i = 0 ; i < v_vars.size() ; i++ )
  value_k -=  v_vars[ i ]->get_value() * SubG[ i ];

 return( value_k );

 } // end( LukFiFunction::get_linearization_constant )

/*--------------------------------------------------------------------------*/

ThinVarDepInterface::Index LukFiBlock::LukFiFunction::is_active(
					         const Variable * var ) const
{
 auto idx = std::find_if( v_vars.begin() , v_vars.end() ,
 			   [ & var ]( const auto & p ) -> bool {
 			    return( p == var );
 			    } );
 return( idx != v_vars.end() ? std::distance( v_vars.begin(), idx )
 	                       : Inf< Index >() );

 } // end( LukFiFunction::is_active )

/*--------------------------------------------------------------------------*/

void LukFiBlock::LukFiFunction::map_active( c_Vec_p_Var & vars ,
			                  Subset & map , bool ordered ) const
{
 if( vars.empty() )
  return;

 if( map.size() < vars.size() )
  map.resize( vars.size() );

 if( ordered ) {
  Index found = 0;
  for( Index i = 0 ; i < v_vars.size() ; ++i ) {
   auto itvi = std::lower_bound( vars.begin() , vars.end() , v_vars[ i ] );
   if( itvi != vars.end() ) {
    map[ std::distance( vars.begin() , itvi ) ] = i;
    ++found;
    }
   }
  if( found < vars.size() )
   throw( std::invalid_argument( "map_active: some Variable is not active" )
	  );
  }
 else {
  auto it = map.begin();
  for( auto var : vars ) {
   Index i = LukFiBlock::LukFiFunction::is_active( var );
   if( i >= v_vars.size() )
    throw( std::invalid_argument( "map_active: some Variable is not active" )
	   );
   *(it++) = i;
   }
  }
 }  // end( LukFiFunction::map_active )

/*--------------------------------------------------------------------------*/
/*------------------- METHODS FOR HANDLING THE PARAMETERS ------------------*/
/*--------------------------------------------------------------------------*/

int LukFiBlock::LukFiFunction::get_dflt_int_par( idx_type par ) const
{
 if( ( par >= intLastParC05F ) && ( par < intLastParLukF ) )
  return( dflt_int_par[ par - intLastParC05F ] );
 else
  return( C05Function::get_dflt_int_par( par ) );

 } // end ( LukFiFunction::get_dflt_int_par )

/*--------------------------------------------------------------------------*/

int LukFiBlock::LukFiFunction::get_int_par( idx_type par ) const
{
 switch( par ) {
  case( intGPMaxSz ):
   return( GPMaxSz );
   break;
  case( intNrCmp ):
   return( NrCmp );
   break;
  case( intseed ):
   return( seed );
   break;
  default:
   return( C05Function::get_dflt_int_par( par ) );
  }
 } // end( LukFiFunction::get_int_par )

/*--------------------------------------------------------------------------*/

ThinComputeInterface::idx_type LukFiBlock::LukFiFunction::int_par_str2idx(
					     const std::string & name ) const
{
 // these may be many enough as to warrant using a map
 const auto it = int_pars_map.find( name );
 if( it != int_pars_map.end() )
  return( it->second );
 else
  return( C05Function::int_par_str2idx( name ) );
 } // end( LukFiFunction::int_par_str2idx )

/*--------------------------------------------------------------------------*/

const std::string & LukFiBlock::LukFiFunction::int_par_idx2str(
							 idx_type idx ) const
{
 if( ( idx >= intLastParC05F ) && ( idx < intLastParLukF ) )
  return( int_pars_str[ idx - intLastParC05F ] );
 else
  return( C05Function::int_par_idx2str( idx ) );
 } // end( LukFiFunction::int_par_idx2str )

/*--------------------------------------------------------------------------*/
/*--------------------- End File LukFiBlock.cpp ----------------------------*/
/*--------------------------------------------------------------------------*/
